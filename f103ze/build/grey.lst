ARM GAS  /tmp/ccBaawNW.s 			page 1


   1              		.cpu cortex-m3
   2              		.eabi_attribute 20, 1
   3              		.eabi_attribute 21, 1
   4              		.eabi_attribute 23, 3
   5              		.eabi_attribute 24, 1
   6              		.eabi_attribute 25, 1
   7              		.eabi_attribute 26, 1
   8              		.eabi_attribute 30, 6
   9              		.eabi_attribute 34, 1
  10              		.eabi_attribute 18, 4
  11              		.file	"grey.c"
  12              		.text
  13              	.Ltext0:
  14              		.cfi_sections	.debug_frame
  15              		.global	MidGreyVal
  16              		.section	.data.MidGreyVal,"aw"
  19              	MidGreyVal:
  20 0000 45       		.byte	69
  21              		.global	cutImg
  22              		.section	.bss.cutImg,"aw",%nobits
  23              		.align	2
  26              	cutImg:
  27 0000 00000000 		.space	9600
  27      00000000 
  27      00000000 
  27      00000000 
  27      00000000 
  28              		.global	leftBlackLoc
  29              		.section	.bss.leftBlackLoc,"aw",%nobits
  30              		.align	2
  33              	leftBlackLoc:
  34 0000 00000000 		.space	20
  34      00000000 
  34      00000000 
  34      00000000 
  34      00000000 
  35              		.global	rightBlackLoc
  36              		.section	.bss.rightBlackLoc,"aw",%nobits
  37              		.align	2
  40              	rightBlackLoc:
  41 0000 00000000 		.space	20
  41      00000000 
  41      00000000 
  41      00000000 
  41      00000000 
  42              		.global	maxUsefulBlackLine
  43              		.section	.bss.maxUsefulBlackLine,"aw",%nobits
  44              		.align	2
  47              	maxUsefulBlackLine:
  48 0000 00000000 		.space	20
  48      00000000 
  48      00000000 
  48      00000000 
  48      00000000 
  49              		.global	maxUsefulLineLen
  50              		.section	.bss.maxUsefulLineLen,"aw",%nobits
  53              	maxUsefulLineLen:
ARM GAS  /tmp/ccBaawNW.s 			page 2


  54 0000 00       		.space	1
  55              		.global	maxUsefulBlackHeight
  56              		.section	.bss.maxUsefulBlackHeight,"aw",%nobits
  57              		.align	2
  60              	maxUsefulBlackHeight:
  61 0000 00000000 		.space	20
  61      00000000 
  61      00000000 
  61      00000000 
  61      00000000 
  62              		.global	overK
  63              		.section	.bss.overK,"aw",%nobits
  64              		.align	3
  67              	overK:
  68 0000 00000000 		.space	8
  68      00000000 
  69              		.global	b
  70              		.section	.bss.b,"aw",%nobits
  71              		.align	2
  74              	b:
  75 0000 00000000 		.space	4
  76              		.global	lineDeviationLoc
  77              		.section	.bss.lineDeviationLoc,"aw",%nobits
  78              		.align	2
  81              	lineDeviationLoc:
  82 0000 00000000 		.space	4
  83              		.global	FLAG_BORDER
  84              		.section	.bss.FLAG_BORDER,"aw",%nobits
  87              	FLAG_BORDER:
  88 0000 00       		.space	1
  89              		.global	devLocRes
  90              		.section	.bss.devLocRes,"aw",%nobits
  93              	devLocRes:
  94 0000 00       		.space	1
  95              		.section	.text.cameraOperation,"ax",%progbits
  96              		.align	1
  97              		.global	cameraOperation
  98              		.arch armv7-m
  99              		.syntax unified
 100              		.thumb
 101              		.thumb_func
 102              		.fpu softvfp
 104              	cameraOperation:
 105              	.LFB63:
 106              		.file 1 "hardware/src/grey.c"
   1:hardware/src/grey.c **** #include "AllHead.h"
   2:hardware/src/grey.c **** #include "grey.h"
   3:hardware/src/grey.c **** #include "ov7670.h"
   4:hardware/src/grey.c **** #include "lcd.h"
   5:hardware/src/grey.c **** #include "exti.h"
   6:hardware/src/grey.c **** #include "string.h"
   7:hardware/src/grey.c **** #include "move.h"
   8:hardware/src/grey.c **** 
   9:hardware/src/grey.c **** #if defined(BIKING) && BIKING
  10:hardware/src/grey.c **** extern u8 RUNNING;
  11:hardware/src/grey.c **** #endif
  12:hardware/src/grey.c **** 
ARM GAS  /tmp/ccBaawNW.s 			page 3


  13:hardware/src/grey.c **** #if defined(FENCHA_TEST) && FENCHA_TEST
  14:hardware/src/grey.c **** u8 max_black_fencha = 80;
  15:hardware/src/grey.c **** #if defined(MAP_TESTA) && MAP_TESTA
  16:hardware/src/grey.c **** extern u8 fencha_times;
  17:hardware/src/grey.c **** #endif
  18:hardware/src/grey.c **** #endif
  19:hardware/src/grey.c **** 
  20:hardware/src/grey.c **** // u8 MidGreyVal = 0x78;//可调阀值
  21:hardware/src/grey.c **** // u8 MidGreyVal = 0x60;//可调阀值  for wet day in windows
  22:hardware/src/grey.c **** // u8 MidGreyVal = 0x58;//可调阀值 for day test in floor
  23:hardware/src/grey.c **** // u8 MidGreyVal = 0x36;//可调阀值 for night test in windows
  24:hardware/src/grey.c **** // u8 MidGreyVal = 0x48;//可调阀值 for night test in floor  fail!!
  25:hardware/src/grey.c **** u8 MidGreyVal = 0x45;//可调阀值 for night test in A4 paper
  26:hardware/src/grey.c **** 
  27:hardware/src/grey.c **** // //截取出来的图片 是原图的1/8
  28:hardware/src/grey.c **** u8 cutImg[NEEDHEIGHT][NEEDWITH] = {0};
  29:hardware/src/grey.c **** // /*存储左右边界的黑点位置，大小为截出来的图片高度除以隔行扫描数*/
  30:hardware/src/grey.c **** u8 leftBlackLoc[(NEEDHEIGHT)/(SKIPLINE)]  = {0};
  31:hardware/src/grey.c **** u8 rightBlackLoc[(NEEDHEIGHT)/(SKIPLINE)] = {0};
  32:hardware/src/grey.c **** /*存储最为有效的段，在左右边界中挑选出来*/
  33:hardware/src/grey.c **** u8 maxUsefulBlackLine[(NEEDHEIGHT)/(SKIPLINE)] = {0};
  34:hardware/src/grey.c **** u8 maxUsefulLineLen = 0;
  35:hardware/src/grey.c **** //存储最长有效段的高度位置
  36:hardware/src/grey.c **** u8 maxUsefulBlackHeight[(NEEDHEIGHT)/(SKIPLINE)] = {0};
  37:hardware/src/grey.c **** extern u8 ov_sta;	//在exit.c里 面定义
  38:hardware/src/grey.c **** extern u8 ov_frame;	//在timer.c里面定义		
  39:hardware/src/grey.c **** /*拟合以后的斜率*/
  40:hardware/src/grey.c **** double overK = 0;
  41:hardware/src/grey.c **** int b;
  42:hardware/src/grey.c **** /*检测到的直线相对于中线位置的偏移*/
  43:hardware/src/grey.c **** int  lineDeviationLoc;
  44:hardware/src/grey.c **** u8 FLAG_BORDER = 0;
  45:hardware/src/grey.c **** u8 devLocRes = 0;
  46:hardware/src/grey.c **** 
  47:hardware/src/grey.c **** /*
  48:hardware/src/grey.c **** 函数功能，统一调用图像采集到数据处理的函数
  49:hardware/src/grey.c **** */
  50:hardware/src/grey.c **** void cameraOperation(void)
  51:hardware/src/grey.c **** {  
 107              		.loc 1 51 1
 108              		.cfi_startproc
 109              		@ args = 0, pretend = 0, frame = 24
 110              		@ frame_needed = 1, uses_anonymous_args = 0
 111 0000 80B5     		push	{r7, lr}
 112              	.LCFI0:
 113              		.cfi_def_cfa_offset 8
 114              		.cfi_offset 7, -8
 115              		.cfi_offset 14, -4
 116 0002 88B0     		sub	sp, sp, #32
 117              	.LCFI1:
 118              		.cfi_def_cfa_offset 40
 119 0004 02AF     		add	r7, sp, #8
 120              	.LCFI2:
 121              		.cfi_def_cfa 7, 32
  52:hardware/src/grey.c **** 	u8 res,res1,res2,i;
  53:hardware/src/grey.c **** 	u8 test_str[20] = {0};
 122              		.loc 1 53 5
ARM GAS  /tmp/ccBaawNW.s 			page 4


 123 0006 0023     		movs	r3, #0
 124 0008 3B60     		str	r3, [r7]
 125 000a 3B1D     		adds	r3, r7, #4
 126 000c 0022     		movs	r2, #0
 127 000e 1A60     		str	r2, [r3]
 128 0010 5A60     		str	r2, [r3, #4]
 129 0012 9A60     		str	r2, [r3, #8]
 130 0014 DA60     		str	r2, [r3, #12]
  54:hardware/src/grey.c **** 	static u8 line2stop = 0;
  55:hardware/src/grey.c **** 	static u8 slope2stop = 0;
  56:hardware/src/grey.c **** 	i = res2 = res1 = res = 0;
 131              		.loc 1 56 24
 132 0016 0023     		movs	r3, #0
 133 0018 FB75     		strb	r3, [r7, #23]
 134              		.loc 1 56 18
 135 001a FB7D     		ldrb	r3, [r7, #23]
 136 001c BB75     		strb	r3, [r7, #22]
 137              		.loc 1 56 11
 138 001e BB7D     		ldrb	r3, [r7, #22]
 139 0020 7B75     		strb	r3, [r7, #21]
 140              		.loc 1 56 4
 141 0022 7B7D     		ldrb	r3, [r7, #21]
 142 0024 3B75     		strb	r3, [r7, #20]
  57:hardware/src/grey.c ****     camera_refresh();//图像采集二值化以及LCD显示
 143              		.loc 1 57 5
 144 0026 FFF7FEFF 		bl	camera_refresh
  58:hardware/src/grey.c **** 	/*紧接着分析边沿，获取左右黑点位置，最后一个参数为检测时的间隔行数*/
  59:hardware/src/grey.c **** 	getLineEdge(leftBlackLoc,rightBlackLoc,1,NEEDHEIGHT-1,SKIPLINE);   //the first is all 0,showing in
 145              		.loc 1 59 2
 146 002a 0423     		movs	r3, #4
 147 002c 0093     		str	r3, [sp]
 148 002e 4F23     		movs	r3, #79
 149 0030 0122     		movs	r2, #1
 150 0032 2C49     		ldr	r1, .L5
 151 0034 2C48     		ldr	r0, .L5+4
 152 0036 FFF7FEFF 		bl	getLineEdge
  60:hardware/src/grey.c **** #if defined(DEBUG_CAMERA) && DEBUG_CAMERA
  61:hardware/src/grey.c **** 	for(i=0;i<(NEEDHEIGHT)/(SKIPLINE);i++){
  62:hardware/src/grey.c **** 		printf("%d:%d_%d ",i,leftBlackLoc[i],rightBlackLoc[i]);
  63:hardware/src/grey.c **** 	}
  64:hardware/src/grey.c **** 	printf("\r\n\r\n");
  65:hardware/src/grey.c **** #endif
  66:hardware/src/grey.c **** #if defined(MAP_TESTB) && MAP_TESTB	
  67:hardware/src/grey.c **** 	find_fencha_move();
  68:hardware/src/grey.c **** #endif
  69:hardware/src/grey.c **** 	/*获取最长的有效段，只取一个有效段 save in maxUsefulBlackLine and maxUsefulBlackHeight*/
  70:hardware/src/grey.c ****     res = getUsefulLine();
 153              		.loc 1 70 11
 154 003a FFF7FEFF 		bl	getUsefulLine
 155 003e 0346     		mov	r3, r0
 156              		.loc 1 70 9
 157 0040 FB75     		strb	r3, [r7, #23]
  71:hardware/src/grey.c **** 	// printToUart();
  72:hardware/src/grey.c ****     if(res == BOTHLOST)//完全丢失，需要做的动作
 158              		.loc 1 72 7
 159 0042 FB7D     		ldrb	r3, [r7, #23]	@ zero_extendqisi2
 160 0044 0A2B     		cmp	r3, #10
ARM GAS  /tmp/ccBaawNW.s 			page 5


 161 0046 10D1     		bne	.L2
  73:hardware/src/grey.c **** 	{
  74:hardware/src/grey.c **** 		//printf("NULL Slope\n");
  75:hardware/src/grey.c **** 		line2stop++;
 162              		.loc 1 75 12
 163 0048 284B     		ldr	r3, .L5+8
 164 004a 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 165 004c 0133     		adds	r3, r3, #1
 166 004e DAB2     		uxtb	r2, r3
 167 0050 264B     		ldr	r3, .L5+8
 168 0052 1A70     		strb	r2, [r3]
  76:hardware/src/grey.c **** 		if(line2stop > 100){
 169              		.loc 1 76 16
 170 0054 254B     		ldr	r3, .L5+8
 171 0056 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 172              		.loc 1 76 5
 173 0058 642B     		cmp	r3, #100
 174 005a 3CD9     		bls	.L3
  77:hardware/src/grey.c **** 			printStopMess(1);
 175              		.loc 1 77 4
 176 005c 0120     		movs	r0, #1
 177 005e FFF7FEFF 		bl	printStopMess
  78:hardware/src/grey.c **** #if defined(BIKING) && BIKING
  79:hardware/src/grey.c **** 			RUNNING = 0;
 178              		.loc 1 79 12
 179 0062 234B     		ldr	r3, .L5+12
 180 0064 0022     		movs	r2, #0
 181 0066 1A70     		strb	r2, [r3]
 182 0068 35E0     		b	.L3
 183              	.L2:
 184              	.LBB2:
  80:hardware/src/grey.c **** #endif
  81:hardware/src/grey.c **** 		}
  82:hardware/src/grey.c **** 	}
  83:hardware/src/grey.c **** 	else //其他情况都有斜率，试着计算出来
  84:hardware/src/grey.c **** 	{
  85:hardware/src/grey.c **** 		line2stop = 0;
 185              		.loc 1 85 13
 186 006a 204B     		ldr	r3, .L5+8
 187 006c 0022     		movs	r2, #0
 188 006e 1A70     		strb	r2, [r3]
  86:hardware/src/grey.c **** 		/*使用最小二乘法计算出斜率*/
  87:hardware/src/grey.c **** 		// res1 = regression(maxUsefulBlackLine,&maxUsefulLineLen,&overK,&b);
  88:hardware/src/grey.c **** 		res1 = regression(maxUsefulBlackLine,maxUsefulBlackHeight,&maxUsefulLineLen,&overK,&b);
 189              		.loc 1 88 10
 190 0070 204B     		ldr	r3, .L5+16
 191 0072 0093     		str	r3, [sp]
 192 0074 204B     		ldr	r3, .L5+20
 193 0076 214A     		ldr	r2, .L5+24
 194 0078 2149     		ldr	r1, .L5+28
 195 007a 2248     		ldr	r0, .L5+32
 196 007c FFF7FEFF 		bl	regression
 197 0080 0346     		mov	r3, r0
 198              		.loc 1 88 8
 199 0082 BB75     		strb	r3, [r7, #22]
  89:hardware/src/grey.c **** 		// printToUart();
  90:hardware/src/grey.c **** 		if(res1 == GOTSLOPE)
ARM GAS  /tmp/ccBaawNW.s 			page 6


 200              		.loc 1 90 5
 201 0084 BB7D     		ldrb	r3, [r7, #22]	@ zero_extendqisi2
 202 0086 0C2B     		cmp	r3, #12
 203 0088 18D1     		bne	.L4
  91:hardware/src/grey.c **** 		{
  92:hardware/src/grey.c **** 			slope2stop = 0;
 204              		.loc 1 92 15
 205 008a 1F4B     		ldr	r3, .L5+36
 206 008c 0022     		movs	r2, #0
 207 008e 1A70     		strb	r2, [r3]
  93:hardware/src/grey.c **** 			/*专门做左右边界偏移检测的工作*/
  94:hardware/src/grey.c **** 			res2 = getCmdByDeviLoc();//根据直线相对的偏移获取的命令
 208              		.loc 1 94 11
 209 0090 FFF7FEFF 		bl	getCmdByDeviLoc
 210 0094 0346     		mov	r3, r0
 211              		.loc 1 94 9
 212 0096 7B75     		strb	r3, [r7, #21]
  95:hardware/src/grey.c **** #if defined(BIKING) && BIKING
  96:hardware/src/grey.c **** 			motation();
 213              		.loc 1 96 4
 214 0098 FFF7FEFF 		bl	motation
  97:hardware/src/grey.c **** #endif
  98:hardware/src/grey.c **** 			print2lcd();
 215              		.loc 1 98 4
 216 009c FFF7FEFF 		bl	print2lcd
  99:hardware/src/grey.c **** 			maxUsefulLineLen = 0;
 217              		.loc 1 99 21
 218 00a0 164B     		ldr	r3, .L5+24
 219 00a2 0022     		movs	r2, #0
 220 00a4 1A70     		strb	r2, [r3]
 100:hardware/src/grey.c **** 	      	memset(maxUsefulBlackLine,0,(NEEDHEIGHT)/(SKIPLINE));
 221              		.loc 1 100 9
 222 00a6 1422     		movs	r2, #20
 223 00a8 0021     		movs	r1, #0
 224 00aa 1648     		ldr	r0, .L5+32
 225 00ac FFF7FEFF 		bl	memset
 101:hardware/src/grey.c **** 	      	memset(maxUsefulBlackHeight,0,(NEEDHEIGHT)/(SKIPLINE));
 226              		.loc 1 101 9
 227 00b0 1422     		movs	r2, #20
 228 00b2 0021     		movs	r1, #0
 229 00b4 1248     		ldr	r0, .L5+28
 230 00b6 FFF7FEFF 		bl	memset
 231 00ba 0CE0     		b	.L3
 232              	.L4:
 102:hardware/src/grey.c **** 		}
 103:hardware/src/grey.c **** 		else
 104:hardware/src/grey.c **** 		{
 105:hardware/src/grey.c **** 			slope2stop++;
 233              		.loc 1 105 14
 234 00bc 124B     		ldr	r3, .L5+36
 235 00be 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 236 00c0 0133     		adds	r3, r3, #1
 237 00c2 DAB2     		uxtb	r2, r3
 238 00c4 104B     		ldr	r3, .L5+36
 239 00c6 1A70     		strb	r2, [r3]
 106:hardware/src/grey.c **** 			if(slope2stop > 100){
 240              		.loc 1 106 18
ARM GAS  /tmp/ccBaawNW.s 			page 7


 241 00c8 0F4B     		ldr	r3, .L5+36
 242 00ca 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 243              		.loc 1 106 6
 244 00cc 642B     		cmp	r3, #100
 245 00ce 02D9     		bls	.L3
 107:hardware/src/grey.c **** 				printStopMess(2);
 246              		.loc 1 107 5
 247 00d0 0220     		movs	r0, #2
 248 00d2 FFF7FEFF 		bl	printStopMess
 249              	.L3:
 250              	.LBE2:
 108:hardware/src/grey.c **** #if defined(BIKING) && BIKING
 109:hardware/src/grey.c **** 				// RUNNING = 0;
 110:hardware/src/grey.c **** #endif
 111:hardware/src/grey.c **** 			}
 112:hardware/src/grey.c **** 		}
 113:hardware/src/grey.c **** 	}
 114:hardware/src/grey.c **** 	memsetBothBlackLoc();//做完一次摄像头采集刷新操作都要清空！
 251              		.loc 1 114 2
 252 00d6 FFF7FEFF 		bl	memsetBothBlackLoc
 115:hardware/src/grey.c **** }
 253              		.loc 1 115 1
 254 00da 00BF     		nop
 255 00dc 1837     		adds	r7, r7, #24
 256              	.LCFI3:
 257              		.cfi_def_cfa_offset 8
 258 00de BD46     		mov	sp, r7
 259              	.LCFI4:
 260              		.cfi_def_cfa_register 13
 261              		@ sp needed
 262 00e0 80BD     		pop	{r7, pc}
 263              	.L6:
 264 00e2 00BF     		.align	2
 265              	.L5:
 266 00e4 00000000 		.word	rightBlackLoc
 267 00e8 00000000 		.word	leftBlackLoc
 268 00ec 00000000 		.word	line2stop.1
 269 00f0 00000000 		.word	RUNNING
 270 00f4 00000000 		.word	b
 271 00f8 00000000 		.word	overK
 272 00fc 00000000 		.word	maxUsefulLineLen
 273 0100 00000000 		.word	maxUsefulBlackHeight
 274 0104 00000000 		.word	maxUsefulBlackLine
 275 0108 00000000 		.word	slope2stop.0
 276              		.cfi_endproc
 277              	.LFE63:
 279              		.section	.rodata
 280              		.align	2
 281              	.LC0:
 282 0000 426F7468 		.ascii	"Both lost\015\000"
 282      206C6F73 
 282      740D00
 283 000b 00       		.align	2
 284              	.LC1:
 285 000c 544F4F20 		.ascii	"TOO LEFT\015\000"
 285      4C454654 
 285      0D00
ARM GAS  /tmp/ccBaawNW.s 			page 8


 286 0016 0000     		.align	2
 287              	.LC2:
 288 0018 544F4F20 		.ascii	"TOO RIGHT\015\000"
 288      52494748 
 288      540D00
 289 0023 00       		.align	2
 290              	.LC3:
 291 0024 4E4F204D 		.ascii	"NO MID LOC\015\000"
 291      4944204C 
 291      4F430D00 
 292              		.align	2
 293              	.LC4:
 294 0030 4E4F204C 		.ascii	"NO LINE WIDTH\015\000"
 294      494E4520 
 294      57494454 
 294      480D00
 295 003f 00       		.align	2
 296              	.LC5:
 297 0040 4445563A 		.ascii	"DEV: %d \015\012\000"
 297      20256420 
 297      0D0A00
 298              		.section	.text.getCmdByDeviLoc,"ax",%progbits
 299              		.align	1
 300              		.global	getCmdByDeviLoc
 301              		.syntax unified
 302              		.thumb
 303              		.thumb_func
 304              		.fpu softvfp
 306              	getCmdByDeviLoc:
 307              	.LFB64:
 116:hardware/src/grey.c **** 
 117:hardware/src/grey.c **** /*专门根据直线的水平位置偏移提供的接口，返回值就是命令*/
 118:hardware/src/grey.c **** int getCmdByDeviLoc()
 119:hardware/src/grey.c **** {
 308              		.loc 1 119 1
 309              		.cfi_startproc
 310              		@ args = 0, pretend = 0, frame = 0
 311              		@ frame_needed = 1, uses_anonymous_args = 0
 312 0000 80B5     		push	{r7, lr}
 313              	.LCFI5:
 314              		.cfi_def_cfa_offset 8
 315              		.cfi_offset 7, -8
 316              		.cfi_offset 14, -4
 317 0002 00AF     		add	r7, sp, #0
 318              	.LCFI6:
 319              		.cfi_def_cfa_register 7
 120:hardware/src/grey.c **** 	// u8 devLocRes = 0;  
 121:hardware/src/grey.c **** 	devLocRes = getLineLocCompare2MidLine(&lineDeviationLoc);	
 320              		.loc 1 121 14
 321 0004 6648     		ldr	r0, .L26
 322 0006 FFF7FEFF 		bl	getLineLocCompare2MidLine
 323 000a 0346     		mov	r3, r0
 324              		.loc 1 121 12
 325 000c DAB2     		uxtb	r2, r3
 326 000e 654B     		ldr	r3, .L26+4
 327 0010 1A70     		strb	r2, [r3]
 122:hardware/src/grey.c **** 	switch(devLocRes)
ARM GAS  /tmp/ccBaawNW.s 			page 9


 328              		.loc 1 122 2
 329 0012 644B     		ldr	r3, .L26+4
 330 0014 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 331 0016 0A3B     		subs	r3, r3, #10
 332 0018 1B2B     		cmp	r3, #27
 333 001a 00F2BE80 		bhi	.L8
 334 001e 01A2     		adr	r2, .L10
 335 0020 52F823F0 		ldr	pc, [r2, r3, lsl #2]
 336              		.p2align 2
 337              	.L10:
 338 0024 95000000 		.word	.L15+1
 339 0028 9B010000 		.word	.L8+1
 340 002c 9B010000 		.word	.L8+1
 341 0030 9B010000 		.word	.L8+1
 342 0034 9B010000 		.word	.L8+1
 343 0038 9B010000 		.word	.L8+1
 344 003c 9B010000 		.word	.L8+1
 345 0040 9B010000 		.word	.L8+1
 346 0044 9B010000 		.word	.L8+1
 347 0048 9B010000 		.word	.L8+1
 348 004c 9B010000 		.word	.L8+1
 349 0050 9B010000 		.word	.L8+1
 350 0054 9F000000 		.word	.L14+1
 351 0058 A9000000 		.word	.L13+1
 352 005c C7000000 		.word	.L12+1
 353 0060 B3000000 		.word	.L11+1
 354 0064 9B010000 		.word	.L8+1
 355 0068 9B010000 		.word	.L8+1
 356 006c 9B010000 		.word	.L8+1
 357 0070 9B010000 		.word	.L8+1
 358 0074 9B010000 		.word	.L8+1
 359 0078 9B010000 		.word	.L8+1
 360 007c 9B010000 		.word	.L8+1
 361 0080 9B010000 		.word	.L8+1
 362 0084 9B010000 		.word	.L8+1
 363 0088 9B010000 		.word	.L8+1
 364 008c 9B010000 		.word	.L8+1
 365 0090 BD000000 		.word	.L9+1
 366              		.p2align 1
 367              	.L15:
 368              	.LBB3:
 123:hardware/src/grey.c **** 	{
 124:hardware/src/grey.c **** 		case BOTHLOST:{
 125:hardware/src/grey.c **** 			printf("Both lost\r\n");return BOTHLOST;
 369              		.loc 1 125 4
 370 0094 4448     		ldr	r0, .L26+8
 371 0096 FFF7FEFF 		bl	puts
 372              		.loc 1 125 35
 373 009a 0A23     		movs	r3, #10
 374 009c 7EE0     		b	.L16
 375              	.L14:
 376              	.LBE3:
 377              	.LBB4:
 126:hardware/src/grey.c **** 		}
 127:hardware/src/grey.c **** 		case TOOLEFT:{
 128:hardware/src/grey.c **** 			printf("TOO LEFT\r\n");return TOOLEFT;
 378              		.loc 1 128 4
ARM GAS  /tmp/ccBaawNW.s 			page 10


 379 009e 4348     		ldr	r0, .L26+12
 380 00a0 FFF7FEFF 		bl	puts
 381              		.loc 1 128 34
 382 00a4 1623     		movs	r3, #22
 383 00a6 79E0     		b	.L16
 384              	.L13:
 385              	.LBE4:
 386              	.LBB5:
 129:hardware/src/grey.c **** 		}
 130:hardware/src/grey.c **** 		case TOORIGHT:{
 131:hardware/src/grey.c **** 			printf("TOO RIGHT\r\n");return TOORIGHT;
 387              		.loc 1 131 4
 388 00a8 4148     		ldr	r0, .L26+16
 389 00aa FFF7FEFF 		bl	puts
 390              		.loc 1 131 35
 391 00ae 1723     		movs	r3, #23
 392 00b0 74E0     		b	.L16
 393              	.L11:
 394              	.LBE5:
 395              	.LBB6:
 132:hardware/src/grey.c **** 		}
 133:hardware/src/grey.c **** 		case NOMIDLOC:{
 134:hardware/src/grey.c **** 			printf("NO MID LOC\r\n");return NOMIDLOC;
 396              		.loc 1 134 4
 397 00b2 4048     		ldr	r0, .L26+20
 398 00b4 FFF7FEFF 		bl	puts
 399              		.loc 1 134 36
 400 00b8 1923     		movs	r3, #25
 401 00ba 6FE0     		b	.L16
 402              	.L9:
 403              	.LBE6:
 404              	.LBB7:
 135:hardware/src/grey.c **** 		}
 136:hardware/src/grey.c **** 		case NOLINEWIDTH:{
 137:hardware/src/grey.c **** 			printf("NO LINE WIDTH\r\n");return NOLINEWIDTH;
 405              		.loc 1 137 4
 406 00bc 3E48     		ldr	r0, .L26+24
 407 00be FFF7FEFF 		bl	puts
 408              		.loc 1 137 39
 409 00c2 2523     		movs	r3, #37
 410 00c4 6AE0     		b	.L16
 411              	.L12:
 412              	.LBE7:
 413              	.LBB8:
 138:hardware/src/grey.c **** 		}
 139:hardware/src/grey.c **** 		case GETMIDLOC:{
 140:hardware/src/grey.c **** 			printf("DEV: %d \r\n",lineDeviationLoc);
 414              		.loc 1 140 4
 415 00c6 364B     		ldr	r3, .L26
 416 00c8 1B68     		ldr	r3, [r3]
 417 00ca 1946     		mov	r1, r3
 418 00cc 3B48     		ldr	r0, .L26+28
 419 00ce FFF7FEFF 		bl	printf
 141:hardware/src/grey.c **** 			if((lineDeviationLoc >= 0) && (lineDeviationLoc <= 10)) return RIGHTDEVI0_10;
 420              		.loc 1 141 25
 421 00d2 334B     		ldr	r3, .L26
 422 00d4 1B68     		ldr	r3, [r3]
ARM GAS  /tmp/ccBaawNW.s 			page 11


 423              		.loc 1 141 6
 424 00d6 002B     		cmp	r3, #0
 425 00d8 05DB     		blt	.L17
 426              		.loc 1 141 52 discriminator 1
 427 00da 314B     		ldr	r3, .L26
 428 00dc 1B68     		ldr	r3, [r3]
 429              		.loc 1 141 31 discriminator 1
 430 00de 0A2B     		cmp	r3, #10
 431 00e0 01DC     		bgt	.L17
 432              		.loc 1 141 67 discriminator 2
 433 00e2 1A23     		movs	r3, #26
 434 00e4 5AE0     		b	.L16
 435              	.L17:
 142:hardware/src/grey.c **** 			if((lineDeviationLoc <= 0) && (lineDeviationLoc >= -10)) return LEFTDEVI0_10;
 436              		.loc 1 142 25
 437 00e6 2E4B     		ldr	r3, .L26
 438 00e8 1B68     		ldr	r3, [r3]
 439              		.loc 1 142 6
 440 00ea 002B     		cmp	r3, #0
 441 00ec 06DC     		bgt	.L18
 442              		.loc 1 142 52 discriminator 1
 443 00ee 2C4B     		ldr	r3, .L26
 444 00f0 1B68     		ldr	r3, [r3]
 445              		.loc 1 142 31 discriminator 1
 446 00f2 13F10A0F 		cmn	r3, #10
 447 00f6 01DB     		blt	.L18
 448              		.loc 1 142 68 discriminator 2
 449 00f8 1B23     		movs	r3, #27
 450 00fa 4FE0     		b	.L16
 451              	.L18:
 143:hardware/src/grey.c **** 			if((lineDeviationLoc > 10 ) && (lineDeviationLoc <= 20)) return RIGHTDEVI10_20;
 452              		.loc 1 143 25
 453 00fc 284B     		ldr	r3, .L26
 454 00fe 1B68     		ldr	r3, [r3]
 455              		.loc 1 143 6
 456 0100 0A2B     		cmp	r3, #10
 457 0102 05DD     		ble	.L19
 458              		.loc 1 143 53 discriminator 1
 459 0104 264B     		ldr	r3, .L26
 460 0106 1B68     		ldr	r3, [r3]
 461              		.loc 1 143 32 discriminator 1
 462 0108 142B     		cmp	r3, #20
 463 010a 01DC     		bgt	.L19
 464              		.loc 1 143 68 discriminator 2
 465 010c 1C23     		movs	r3, #28
 466 010e 45E0     		b	.L16
 467              	.L19:
 144:hardware/src/grey.c **** 			if((lineDeviationLoc < -10) && (lineDeviationLoc >= -20)) return LEFTDEVI10_20;
 468              		.loc 1 144 25
 469 0110 234B     		ldr	r3, .L26
 470 0112 1B68     		ldr	r3, [r3]
 471              		.loc 1 144 6
 472 0114 13F10A0F 		cmn	r3, #10
 473 0118 06DA     		bge	.L20
 474              		.loc 1 144 53 discriminator 1
 475 011a 214B     		ldr	r3, .L26
 476 011c 1B68     		ldr	r3, [r3]
ARM GAS  /tmp/ccBaawNW.s 			page 12


 477              		.loc 1 144 32 discriminator 1
 478 011e 13F1140F 		cmn	r3, #20
 479 0122 01DB     		blt	.L20
 480              		.loc 1 144 69 discriminator 2
 481 0124 1D23     		movs	r3, #29
 482 0126 39E0     		b	.L16
 483              	.L20:
 145:hardware/src/grey.c **** 			if((lineDeviationLoc > 20 ) && (lineDeviationLoc <= 30)) return RIGHTDEVI20_30;
 484              		.loc 1 145 25
 485 0128 1D4B     		ldr	r3, .L26
 486 012a 1B68     		ldr	r3, [r3]
 487              		.loc 1 145 6
 488 012c 142B     		cmp	r3, #20
 489 012e 05DD     		ble	.L21
 490              		.loc 1 145 53 discriminator 1
 491 0130 1B4B     		ldr	r3, .L26
 492 0132 1B68     		ldr	r3, [r3]
 493              		.loc 1 145 32 discriminator 1
 494 0134 1E2B     		cmp	r3, #30
 495 0136 01DC     		bgt	.L21
 496              		.loc 1 145 68 discriminator 2
 497 0138 1E23     		movs	r3, #30
 498 013a 2FE0     		b	.L16
 499              	.L21:
 146:hardware/src/grey.c **** 			if((lineDeviationLoc < -20) && (lineDeviationLoc >= -30)) return LEFTDEVI20_30;
 500              		.loc 1 146 25
 501 013c 184B     		ldr	r3, .L26
 502 013e 1B68     		ldr	r3, [r3]
 503              		.loc 1 146 6
 504 0140 13F1140F 		cmn	r3, #20
 505 0144 06DA     		bge	.L22
 506              		.loc 1 146 53 discriminator 1
 507 0146 164B     		ldr	r3, .L26
 508 0148 1B68     		ldr	r3, [r3]
 509              		.loc 1 146 32 discriminator 1
 510 014a 13F11E0F 		cmn	r3, #30
 511 014e 01DB     		blt	.L22
 512              		.loc 1 146 69 discriminator 2
 513 0150 1F23     		movs	r3, #31
 514 0152 23E0     		b	.L16
 515              	.L22:
 147:hardware/src/grey.c **** 			if((lineDeviationLoc > 30 ) && (lineDeviationLoc <= 40)) return RIGHTDEVI30_40;
 516              		.loc 1 147 25
 517 0154 124B     		ldr	r3, .L26
 518 0156 1B68     		ldr	r3, [r3]
 519              		.loc 1 147 6
 520 0158 1E2B     		cmp	r3, #30
 521 015a 05DD     		ble	.L23
 522              		.loc 1 147 53 discriminator 1
 523 015c 104B     		ldr	r3, .L26
 524 015e 1B68     		ldr	r3, [r3]
 525              		.loc 1 147 32 discriminator 1
 526 0160 282B     		cmp	r3, #40
 527 0162 01DC     		bgt	.L23
 528              		.loc 1 147 68 discriminator 2
 529 0164 2023     		movs	r3, #32
 530 0166 19E0     		b	.L16
ARM GAS  /tmp/ccBaawNW.s 			page 13


 531              	.L23:
 148:hardware/src/grey.c **** 			if((lineDeviationLoc < -30) && (lineDeviationLoc >= -40)) return LEFTDEVI30_40;
 532              		.loc 1 148 25
 533 0168 0D4B     		ldr	r3, .L26
 534 016a 1B68     		ldr	r3, [r3]
 535              		.loc 1 148 6
 536 016c 13F11E0F 		cmn	r3, #30
 537 0170 06DA     		bge	.L24
 538              		.loc 1 148 53 discriminator 1
 539 0172 0B4B     		ldr	r3, .L26
 540 0174 1B68     		ldr	r3, [r3]
 541              		.loc 1 148 32 discriminator 1
 542 0176 13F1280F 		cmn	r3, #40
 543 017a 01DB     		blt	.L24
 544              		.loc 1 148 69 discriminator 2
 545 017c 2123     		movs	r3, #33
 546 017e 0DE0     		b	.L16
 547              	.L24:
 149:hardware/src/grey.c **** 			if((lineDeviationLoc > 40 )) return RIGHTDEVMORETHAN40;
 548              		.loc 1 149 25
 549 0180 074B     		ldr	r3, .L26
 550 0182 1B68     		ldr	r3, [r3]
 551              		.loc 1 149 6
 552 0184 282B     		cmp	r3, #40
 553 0186 01DD     		ble	.L25
 554              		.loc 1 149 40 discriminator 1
 555 0188 2223     		movs	r3, #34
 556 018a 07E0     		b	.L16
 557              	.L25:
 150:hardware/src/grey.c **** 			if((lineDeviationLoc < -40 )) return LEFTDEVMORETHAN40;
 558              		.loc 1 150 25
 559 018c 044B     		ldr	r3, .L26
 560 018e 1B68     		ldr	r3, [r3]
 561              		.loc 1 150 6
 562 0190 13F1280F 		cmn	r3, #40
 563 0194 01DA     		bge	.L8
 564              		.loc 1 150 41 discriminator 1
 565 0196 2323     		movs	r3, #35
 566 0198 00E0     		b	.L16
 567              	.L8:
 568              	.LBE8:
 151:hardware/src/grey.c **** 		}
 152:hardware/src/grey.c **** 		default:return ERR;
 569              		.loc 1 152 18
 570 019a 1523     		movs	r3, #21
 571              	.L16:
 153:hardware/src/grey.c **** 	}
 154:hardware/src/grey.c **** }
 572              		.loc 1 154 1
 573 019c 1846     		mov	r0, r3
 574 019e 80BD     		pop	{r7, pc}
 575              	.L27:
 576              		.align	2
 577              	.L26:
 578 01a0 00000000 		.word	lineDeviationLoc
 579 01a4 00000000 		.word	devLocRes
 580 01a8 00000000 		.word	.LC0
ARM GAS  /tmp/ccBaawNW.s 			page 14


 581 01ac 0C000000 		.word	.LC1
 582 01b0 18000000 		.word	.LC2
 583 01b4 24000000 		.word	.LC3
 584 01b8 30000000 		.word	.LC4
 585 01bc 40000000 		.word	.LC5
 586              		.cfi_endproc
 587              	.LFE64:
 589              		.section	.text.memsetBothBlackLoc,"ax",%progbits
 590              		.align	1
 591              		.global	memsetBothBlackLoc
 592              		.syntax unified
 593              		.thumb
 594              		.thumb_func
 595              		.fpu softvfp
 597              	memsetBothBlackLoc:
 598              	.LFB65:
 155:hardware/src/grey.c **** 
 156:hardware/src/grey.c **** /*清空两边原始检测到的边缘*/
 157:hardware/src/grey.c **** void memsetBothBlackLoc()
 158:hardware/src/grey.c **** {  
 599              		.loc 1 158 1
 600              		.cfi_startproc
 601              		@ args = 0, pretend = 0, frame = 0
 602              		@ frame_needed = 1, uses_anonymous_args = 0
 603 0000 80B5     		push	{r7, lr}
 604              	.LCFI7:
 605              		.cfi_def_cfa_offset 8
 606              		.cfi_offset 7, -8
 607              		.cfi_offset 14, -4
 608 0002 00AF     		add	r7, sp, #0
 609              	.LCFI8:
 610              		.cfi_def_cfa_register 7
 159:hardware/src/grey.c **** 	memset(leftBlackLoc,0,(NEEDHEIGHT)/(SKIPLINE));
 611              		.loc 1 159 2
 612 0004 1422     		movs	r2, #20
 613 0006 0021     		movs	r1, #0
 614 0008 0448     		ldr	r0, .L29
 615 000a FFF7FEFF 		bl	memset
 160:hardware/src/grey.c **** 	memset(rightBlackLoc,0,(NEEDHEIGHT)/(SKIPLINE));
 616              		.loc 1 160 2
 617 000e 1422     		movs	r2, #20
 618 0010 0021     		movs	r1, #0
 619 0012 0348     		ldr	r0, .L29+4
 620 0014 FFF7FEFF 		bl	memset
 161:hardware/src/grey.c **** }
 621              		.loc 1 161 1
 622 0018 00BF     		nop
 623 001a 80BD     		pop	{r7, pc}
 624              	.L30:
 625              		.align	2
 626              	.L29:
 627 001c 00000000 		.word	leftBlackLoc
 628 0020 00000000 		.word	rightBlackLoc
 629              		.cfi_endproc
 630              	.LFE65:
 632              		.section	.text.cameraRefresh,"ax",%progbits
 633              		.align	1
ARM GAS  /tmp/ccBaawNW.s 			page 15


 634              		.global	cameraRefresh
 635              		.syntax unified
 636              		.thumb
 637              		.thumb_func
 638              		.fpu softvfp
 640              	cameraRefresh:
 641              	.LFB66:
 162:hardware/src/grey.c **** 
 163:hardware/src/grey.c **** /*
 164:hardware/src/grey.c **** 函数功能：从OV7670的FIFO中读出像素，在翻转的基础上进行二值化，并在LCD上显示调试
 165:hardware/src/grey.c **** */
 166:hardware/src/grey.c **** void cameraRefresh(void)
 167:hardware/src/grey.c **** {
 642              		.loc 1 167 1
 643              		.cfi_startproc
 644              		@ args = 0, pretend = 0, frame = 24
 645              		@ frame_needed = 1, uses_anonymous_args = 0
 646 0000 80B5     		push	{r7, lr}
 647              	.LCFI9:
 648              		.cfi_def_cfa_offset 8
 649              		.cfi_offset 7, -8
 650              		.cfi_offset 14, -4
 651 0002 86B0     		sub	sp, sp, #24
 652              	.LCFI10:
 653              		.cfi_def_cfa_offset 32
 654 0004 00AF     		add	r7, sp, #0
 655              	.LCFI11:
 656              		.cfi_def_cfa_register 7
 168:hardware/src/grey.c **** 	u32 m = 0;u32 n = 0;u32 mm = 0;u32 nn = 0;u16 color;
 657              		.loc 1 168 6
 658 0006 0023     		movs	r3, #0
 659 0008 7B61     		str	r3, [r7, #20]
 660              		.loc 1 168 16
 661 000a 0023     		movs	r3, #0
 662 000c 3B61     		str	r3, [r7, #16]
 663              		.loc 1 168 26
 664 000e 0023     		movs	r3, #0
 665 0010 FB60     		str	r3, [r7, #12]
 666              		.loc 1 168 37
 667 0012 0023     		movs	r3, #0
 668 0014 BB60     		str	r3, [r7, #8]
 169:hardware/src/grey.c **** 	if(ov_sta)//有帧中断更新？
 669              		.loc 1 169 5
 670 0016 664B     		ldr	r3, .L46
 671 0018 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 672              		.loc 1 169 4
 673 001a 002B     		cmp	r3, #0
 674 001c 00F0C480 		beq	.L45
 170:hardware/src/grey.c **** 	{
 171:hardware/src/grey.c **** 		// printf("get ov_sta\r\n");
 172:hardware/src/grey.c **** #if defined(LCD_ON_OFF) && LCD_ON_OFF
 173:hardware/src/grey.c **** 		LCD_Scan_Dir(DFT_SCAN_DIR);	//恢复默认扫描方向 
 675              		.loc 1 173 3
 676 0020 0020     		movs	r0, #0
 677 0022 FFF7FEFF 		bl	LCD_Scan_Dir
 174:hardware/src/grey.c **** #if defined(LCD_SHOW_INFO) && LCD_SHOW_INFO
 175:hardware/src/grey.c **** 		LCD_Set_Window(50,50,120,80);//将显示区域设置到屏幕中央
ARM GAS  /tmp/ccBaawNW.s 			page 16


 678              		.loc 1 175 3
 679 0026 5023     		movs	r3, #80
 680 0028 7822     		movs	r2, #120
 681 002a 3221     		movs	r1, #50
 682 002c 3220     		movs	r0, #50
 683 002e FFF7FEFF 		bl	LCD_Set_Window
 176:hardware/src/grey.c **** #else
 177:hardware/src/grey.c **** 		LCD_Set_Window(100,100,120,80);//将显示区域设置到屏幕中央
 178:hardware/src/grey.c **** #endif
 179:hardware/src/grey.c **** 		LCD_WriteRAM_Prepare();     //开始写入GRAM	
 684              		.loc 1 179 3
 685 0032 FFF7FEFF 		bl	LCD_WriteRAM_Prepare
 180:hardware/src/grey.c **** #endif
 181:hardware/src/grey.c **** 		  
 182:hardware/src/grey.c **** 		OV7670_RRST=0;				//开始复位读指针 
 686              		.loc 1 182 3
 687 0036 5F4B     		ldr	r3, .L46+4
 688              		.loc 1 182 14
 689 0038 0022     		movs	r2, #0
 690 003a 1A60     		str	r2, [r3]
 183:hardware/src/grey.c **** 		OV7670_RCK_L;
 691              		.loc 1 183 3
 692 003c 5E4B     		ldr	r3, .L46+8
 693 003e 0022     		movs	r2, #0
 694 0040 1A60     		str	r2, [r3]
 184:hardware/src/grey.c **** 		OV7670_RCK_H;
 695              		.loc 1 184 3
 696 0042 5D4B     		ldr	r3, .L46+8
 697 0044 0122     		movs	r2, #1
 698 0046 1A60     		str	r2, [r3]
 185:hardware/src/grey.c **** 		OV7670_RCK_L;
 699              		.loc 1 185 3
 700 0048 5B4B     		ldr	r3, .L46+8
 701 004a 0022     		movs	r2, #0
 702 004c 1A60     		str	r2, [r3]
 186:hardware/src/grey.c **** 		OV7670_RRST=1;				//复位读指针结束 
 703              		.loc 1 186 3
 704 004e 594B     		ldr	r3, .L46+4
 705              		.loc 1 186 14
 706 0050 0122     		movs	r2, #1
 707 0052 1A60     		str	r2, [r3]
 187:hardware/src/grey.c **** 		OV7670_RCK_H;
 708              		.loc 1 187 3
 709 0054 584B     		ldr	r3, .L46+8
 710 0056 0122     		movs	r2, #1
 711 0058 1A60     		str	r2, [r3]
 188:hardware/src/grey.c ****       
 189:hardware/src/grey.c **** 		for(m = 0;m < 240;m ++)//行
 712              		.loc 1 189 9
 713 005a 0023     		movs	r3, #0
 714 005c 7B61     		str	r3, [r7, #20]
 715              		.loc 1 189 3
 716 005e 61E0     		b	.L33
 717              	.L38:
 190:hardware/src/grey.c **** 		{
 191:hardware/src/grey.c **** 			for(n = 0;n < 320;n ++)//列
 718              		.loc 1 191 10
ARM GAS  /tmp/ccBaawNW.s 			page 17


 719 0060 0023     		movs	r3, #0
 720 0062 3B61     		str	r3, [r7, #16]
 721              		.loc 1 191 4
 722 0064 57E0     		b	.L34
 723              	.L37:
 192:hardware/src/grey.c **** 			{
 193:hardware/src/grey.c **** 				//读取两个字节的数据
 194:hardware/src/grey.c **** 				OV7670_RCK_L;
 724              		.loc 1 194 5
 725 0066 544B     		ldr	r3, .L46+8
 726 0068 0022     		movs	r2, #0
 727 006a 1A60     		str	r2, [r3]
 195:hardware/src/grey.c **** #if defined(CHANGE_PIN) && CHANGE_PIN
 196:hardware/src/grey.c **** 				color=GPIOF->IDR&0XFF;	//读数据，摄像头使用PC0-7作为数据输入输出，GPIOC的端口输入数据寄存器
 728              		.loc 1 196 16
 729 006c 534B     		ldr	r3, .L46+12
 730 006e 9B68     		ldr	r3, [r3, #8]
 731              		.loc 1 196 21
 732 0070 9BB2     		uxth	r3, r3
 733              		.loc 1 196 10
 734 0072 DBB2     		uxtb	r3, r3
 735 0074 FB80     		strh	r3, [r7, #6]	@ movhi
 197:hardware/src/grey.c **** #else
 198:hardware/src/grey.c **** 				color=GPIOA->IDR&0XFF;	//读数据，摄像头使用PC0-7作为数据输入输出，GPIOC的端口输入数据寄存器
 199:hardware/src/grey.c **** #endif
 200:hardware/src/grey.c **** 				OV7670_RCK_H; 
 736              		.loc 1 200 5
 737 0076 504B     		ldr	r3, .L46+8
 738 0078 0122     		movs	r2, #1
 739 007a 1A60     		str	r2, [r3]
 201:hardware/src/grey.c **** 				color<<=8;  
 740              		.loc 1 201 10
 741 007c FB88     		ldrh	r3, [r7, #6]	@ movhi
 742 007e 1B02     		lsls	r3, r3, #8
 743 0080 FB80     		strh	r3, [r7, #6]	@ movhi
 202:hardware/src/grey.c **** 				OV7670_RCK_L;
 744              		.loc 1 202 5
 745 0082 4D4B     		ldr	r3, .L46+8
 746 0084 0022     		movs	r2, #0
 747 0086 1A60     		str	r2, [r3]
 203:hardware/src/grey.c **** #if defined(CHANGE_PIN) && CHANGE_PIN
 204:hardware/src/grey.c **** 				color|=GPIOF->IDR&0XFF;	//读数据，虽然用不到，但是要是不读这个送color，整个屏幕会出现闪动，所以
 748              		.loc 1 204 17
 749 0088 4C4B     		ldr	r3, .L46+12
 750 008a 9B68     		ldr	r3, [r3, #8]
 751              		.loc 1 204 22
 752 008c DBB2     		uxtb	r3, r3
 753              		.loc 1 204 10
 754 008e 9AB2     		uxth	r2, r3
 755 0090 FB88     		ldrh	r3, [r7, #6]	@ movhi
 756 0092 1343     		orrs	r3, r3, r2
 757 0094 FB80     		strh	r3, [r7, #6]	@ movhi
 205:hardware/src/grey.c **** #else
 206:hardware/src/grey.c **** 				color|=GPIOA->IDR&0XFF;	//读数据，虽然用不到，但是要是不读这个送color，整个屏幕会出现闪动，所以
 207:hardware/src/grey.c **** #endif
 208:hardware/src/grey.c **** 				OV7670_RCK_H; 
 758              		.loc 1 208 5
ARM GAS  /tmp/ccBaawNW.s 			page 18


 759 0096 484B     		ldr	r3, .L46+8
 760 0098 0122     		movs	r2, #1
 761 009a 1A60     		str	r2, [r3]
 209:hardware/src/grey.c **** 				
 210:hardware/src/grey.c **** 				//上面读取的U和V进行清空，舍弃。
 211:hardware/src/grey.c **** 				color &= 0xff00;
 762              		.loc 1 211 11
 763 009c FB88     		ldrh	r3, [r7, #6]	@ movhi
 764 009e 23F0FF03 		bic	r3, r3, #255
 765 00a2 FB80     		strh	r3, [r7, #6]	@ movhi
 212:hardware/src/grey.c **** 				/*
 213:hardware/src/grey.c **** 				判断阀值，进行显示二值
 214:hardware/src/grey.c **** 				但为了显示到LCD上可以看到，使用两个字节进行表示二值
 215:hardware/src/grey.c **** 				*/
 216:hardware/src/grey.c **** 				if( m % 2 == 0)//选中需要的行了，隔着两行
 766              		.loc 1 216 11
 767 00a4 7B69     		ldr	r3, [r7, #20]
 768 00a6 03F00103 		and	r3, r3, #1
 769              		.loc 1 216 7
 770 00aa 002B     		cmp	r3, #0
 771 00ac 30D1     		bne	.L35
 217:hardware/src/grey.c **** 				{
 218:hardware/src/grey.c **** 					if( n % 4 == 0)//选中的列，隔着四列
 772              		.loc 1 218 12
 773 00ae 3B69     		ldr	r3, [r7, #16]
 774 00b0 03F00303 		and	r3, r3, #3
 775              		.loc 1 218 8
 776 00b4 002B     		cmp	r3, #0
 777 00b6 2BD1     		bne	.L35
 219:hardware/src/grey.c **** 					{
 220:hardware/src/grey.c **** 						color >>= 8;
 778              		.loc 1 220 13
 779 00b8 FB88     		ldrh	r3, [r7, #6]
 780 00ba 1B0A     		lsrs	r3, r3, #8
 781 00bc FB80     		strh	r3, [r7, #6]	@ movhi
 221:hardware/src/grey.c **** 						/*进行数组的翻转存储*/
 222:hardware/src/grey.c **** 						if( (u8)color > MidGreyVal) //左移过后，低八位为需要的Y值
 782              		.loc 1 222 11
 783 00be FB88     		ldrh	r3, [r7, #6]	@ movhi
 784 00c0 DAB2     		uxtb	r2, r3
 785              		.loc 1 222 21
 786 00c2 3F4B     		ldr	r3, .L46+16
 787 00c4 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 788              		.loc 1 222 9
 789 00c6 9A42     		cmp	r2, r3
 790 00c8 11D9     		bls	.L36
 223:hardware/src/grey.c **** 						{
 224:hardware/src/grey.c **** 							// cutImg[n / 4][m / 2] = 0xff;//白色
 225:hardware/src/grey.c **** 							cutImg[NEEDHEIGHT-n / 4][NEEDWITH-m / 2] = 0xff;//白色
 791              		.loc 1 225 28
 792 00ca 3B69     		ldr	r3, [r7, #16]
 793 00cc 9B08     		lsrs	r3, r3, #2
 794              		.loc 1 225 25
 795 00ce C3F15002 		rsb	r2, r3, #80
 796              		.loc 1 225 44
 797 00d2 7B69     		ldr	r3, [r7, #20]
 798 00d4 5B08     		lsrs	r3, r3, #1
ARM GAS  /tmp/ccBaawNW.s 			page 19


 799              		.loc 1 225 41
 800 00d6 C3F17801 		rsb	r1, r3, #120
 801              		.loc 1 225 49
 802 00da 3A48     		ldr	r0, .L46+20
 803 00dc 1346     		mov	r3, r2
 804 00de 1B01     		lsls	r3, r3, #4
 805 00e0 9B1A     		subs	r3, r3, r2
 806 00e2 DB00     		lsls	r3, r3, #3
 807 00e4 0344     		add	r3, r3, r0
 808 00e6 0B44     		add	r3, r3, r1
 809 00e8 FF22     		movs	r2, #255
 810 00ea 1A70     		strb	r2, [r3]
 811 00ec 10E0     		b	.L35
 812              	.L36:
 226:hardware/src/grey.c **** 						}
 227:hardware/src/grey.c **** 						else 
 228:hardware/src/grey.c **** 						{
 229:hardware/src/grey.c **** 							// cutImg[n / 4][m / 2] = 0x00;//黑色									
 230:hardware/src/grey.c **** 							cutImg[NEEDHEIGHT-n / 4][NEEDWITH-m / 2] = 0x00;//黑色									
 813              		.loc 1 230 28
 814 00ee 3B69     		ldr	r3, [r7, #16]
 815 00f0 9B08     		lsrs	r3, r3, #2
 816              		.loc 1 230 25
 817 00f2 C3F15002 		rsb	r2, r3, #80
 818              		.loc 1 230 44
 819 00f6 7B69     		ldr	r3, [r7, #20]
 820 00f8 5B08     		lsrs	r3, r3, #1
 821              		.loc 1 230 41
 822 00fa C3F17801 		rsb	r1, r3, #120
 823              		.loc 1 230 49
 824 00fe 3148     		ldr	r0, .L46+20
 825 0100 1346     		mov	r3, r2
 826 0102 1B01     		lsls	r3, r3, #4
 827 0104 9B1A     		subs	r3, r3, r2
 828 0106 DB00     		lsls	r3, r3, #3
 829 0108 0344     		add	r3, r3, r0
 830 010a 0B44     		add	r3, r3, r1
 831 010c 0022     		movs	r2, #0
 832 010e 1A70     		strb	r2, [r3]
 833              	.L35:
 191:hardware/src/grey.c **** 			{
 834              		.loc 1 191 24 discriminator 2
 835 0110 3B69     		ldr	r3, [r7, #16]
 836 0112 0133     		adds	r3, r3, #1
 837 0114 3B61     		str	r3, [r7, #16]
 838              	.L34:
 191:hardware/src/grey.c **** 			{
 839              		.loc 1 191 4 discriminator 1
 840 0116 3B69     		ldr	r3, [r7, #16]
 841 0118 B3F5A07F 		cmp	r3, #320
 842 011c A3D3     		bcc	.L37
 189:hardware/src/grey.c **** 		{
 843              		.loc 1 189 23 discriminator 2
 844 011e 7B69     		ldr	r3, [r7, #20]
 845 0120 0133     		adds	r3, r3, #1
 846 0122 7B61     		str	r3, [r7, #20]
 847              	.L33:
ARM GAS  /tmp/ccBaawNW.s 			page 20


 189:hardware/src/grey.c **** 		{
 848              		.loc 1 189 3 discriminator 1
 849 0124 7B69     		ldr	r3, [r7, #20]
 850 0126 EF2B     		cmp	r3, #239
 851 0128 9AD9     		bls	.L38
 231:hardware/src/grey.c **** 						}
 232:hardware/src/grey.c **** 					}
 233:hardware/src/grey.c **** 				}
 234:hardware/src/grey.c **** 			}
 235:hardware/src/grey.c **** 		}   	
 236:hardware/src/grey.c **** 		ov_sta=0;					//清零帧中断标记
 852              		.loc 1 236 9
 853 012a 214B     		ldr	r3, .L46
 854 012c 0022     		movs	r2, #0
 855 012e 1A70     		strb	r2, [r3]
 237:hardware/src/grey.c **** 		ov_frame++;
 856              		.loc 1 237 11
 857 0130 254B     		ldr	r3, .L46+24
 858 0132 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 859 0134 0133     		adds	r3, r3, #1
 860 0136 DAB2     		uxtb	r2, r3
 861 0138 234B     		ldr	r3, .L46+24
 862 013a 1A70     		strb	r2, [r3]
 238:hardware/src/grey.c **** 		/*
 239:hardware/src/grey.c **** 		将采集到的像素存在数组中以后，再向LCD输出，LCD默认使用从左往右，从上往下的方式
 240:hardware/src/grey.c **** 		那么LCD上显示正向的图片，就说明我上面的数组的翻转做的是正确的。
 241:hardware/src/grey.c **** 		接下来对图像的解析，直接可以使用这个数组中的参数，默认图片就是从左往右，从上往下
 242:hardware/src/grey.c **** 		*/
 243:hardware/src/grey.c **** #if defined(LCD_ON_OFF) && LCD_ON_OFF
 244:hardware/src/grey.c **** 		for(mm = 0;mm < 80;mm ++)  //80行
 863              		.loc 1 244 10
 864 013c 0023     		movs	r3, #0
 865 013e FB60     		str	r3, [r7, #12]
 866              		.loc 1 244 3
 867 0140 2FE0     		b	.L39
 868              	.L44:
 245:hardware/src/grey.c **** 		{
 246:hardware/src/grey.c **** 			for(nn = 0;nn < 120;nn ++)  //120列
 869              		.loc 1 246 11
 870 0142 0023     		movs	r3, #0
 871 0144 BB60     		str	r3, [r7, #8]
 872              		.loc 1 246 4
 873 0146 26E0     		b	.L40
 874              	.L43:
 247:hardware/src/grey.c **** 			{
 248:hardware/src/grey.c **** 				if(cutImg[mm][nn] == 0xff)
 875              		.loc 1 248 18
 876 0148 1E49     		ldr	r1, .L46+20
 877 014a FA68     		ldr	r2, [r7, #12]
 878 014c 1346     		mov	r3, r2
 879 014e 1B01     		lsls	r3, r3, #4
 880 0150 9B1A     		subs	r3, r3, r2
 881 0152 DB00     		lsls	r3, r3, #3
 882 0154 CA18     		adds	r2, r1, r3
 883 0156 BB68     		ldr	r3, [r7, #8]
 884 0158 1344     		add	r3, r3, r2
 885 015a 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
ARM GAS  /tmp/ccBaawNW.s 			page 21


 886              		.loc 1 248 7
 887 015c FF2B     		cmp	r3, #255
 888 015e 06D1     		bne	.L41
 249:hardware/src/grey.c **** 				{
 250:hardware/src/grey.c **** 					color = 0xffff;//黑色
 889              		.loc 1 250 12
 890 0160 4FF6FF73 		movw	r3, #65535
 891 0164 FB80     		strh	r3, [r7, #6]	@ movhi
 251:hardware/src/grey.c **** 					LCD->LCD_RAM = color; 
 892              		.loc 1 251 9
 893 0166 194A     		ldr	r2, .L46+28
 894              		.loc 1 251 19
 895 0168 FB88     		ldrh	r3, [r7, #6]	@ movhi
 896 016a 5380     		strh	r3, [r2, #2]	@ movhi
 897 016c 10E0     		b	.L42
 898              	.L41:
 252:hardware/src/grey.c **** 				}
 253:hardware/src/grey.c **** 				else if(cutImg[mm][nn] == 0x00)
 899              		.loc 1 253 23
 900 016e 1549     		ldr	r1, .L46+20
 901 0170 FA68     		ldr	r2, [r7, #12]
 902 0172 1346     		mov	r3, r2
 903 0174 1B01     		lsls	r3, r3, #4
 904 0176 9B1A     		subs	r3, r3, r2
 905 0178 DB00     		lsls	r3, r3, #3
 906 017a CA18     		adds	r2, r1, r3
 907 017c BB68     		ldr	r3, [r7, #8]
 908 017e 1344     		add	r3, r3, r2
 909 0180 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 910              		.loc 1 253 12
 911 0182 002B     		cmp	r3, #0
 912 0184 04D1     		bne	.L42
 254:hardware/src/grey.c **** 				{
 255:hardware/src/grey.c **** 					color = 0x0000;//白色
 913              		.loc 1 255 12
 914 0186 0023     		movs	r3, #0
 915 0188 FB80     		strh	r3, [r7, #6]	@ movhi
 256:hardware/src/grey.c **** 					LCD->LCD_RAM = color; 
 916              		.loc 1 256 9
 917 018a 104A     		ldr	r2, .L46+28
 918              		.loc 1 256 19
 919 018c FB88     		ldrh	r3, [r7, #6]	@ movhi
 920 018e 5380     		strh	r3, [r2, #2]	@ movhi
 921              	.L42:
 246:hardware/src/grey.c **** 			{
 922              		.loc 1 246 27 discriminator 2
 923 0190 BB68     		ldr	r3, [r7, #8]
 924 0192 0133     		adds	r3, r3, #1
 925 0194 BB60     		str	r3, [r7, #8]
 926              	.L40:
 246:hardware/src/grey.c **** 			{
 927              		.loc 1 246 4 discriminator 1
 928 0196 BB68     		ldr	r3, [r7, #8]
 929 0198 772B     		cmp	r3, #119
 930 019a D5D9     		bls	.L43
 244:hardware/src/grey.c **** 		{
 931              		.loc 1 244 25 discriminator 2
ARM GAS  /tmp/ccBaawNW.s 			page 22


 932 019c FB68     		ldr	r3, [r7, #12]
 933 019e 0133     		adds	r3, r3, #1
 934 01a0 FB60     		str	r3, [r7, #12]
 935              	.L39:
 244:hardware/src/grey.c **** 		{
 936              		.loc 1 244 3 discriminator 1
 937 01a2 FB68     		ldr	r3, [r7, #12]
 938 01a4 4F2B     		cmp	r3, #79
 939 01a6 CCD9     		bls	.L44
 940              	.L45:
 257:hardware/src/grey.c **** 				}
 258:hardware/src/grey.c **** 			}
 259:hardware/src/grey.c **** 		}
 260:hardware/src/grey.c **** #endif
 261:hardware/src/grey.c **** 	 }
 262:hardware/src/grey.c **** }	
 941              		.loc 1 262 1
 942 01a8 00BF     		nop
 943 01aa 1837     		adds	r7, r7, #24
 944              	.LCFI12:
 945              		.cfi_def_cfa_offset 8
 946 01ac BD46     		mov	sp, r7
 947              	.LCFI13:
 948              		.cfi_def_cfa_register 13
 949              		@ sp needed
 950 01ae 80BD     		pop	{r7, pc}
 951              	.L47:
 952              		.align	2
 953              	.L46:
 954 01b0 00000000 		.word	ov_sta
 955 01b4 80012342 		.word	1109590400
 956 01b8 90012342 		.word	1109590416
 957 01bc 001C0140 		.word	1073814528
 958 01c0 00000000 		.word	MidGreyVal
 959 01c4 00000000 		.word	cutImg
 960 01c8 00000000 		.word	ov_frame
 961 01cc FE07006C 		.word	1811941374
 962              		.cfi_endproc
 963              	.LFE66:
 965              		.section	.text.camera_refresh,"ax",%progbits
 966              		.align	1
 967              		.global	camera_refresh
 968              		.syntax unified
 969              		.thumb
 970              		.thumb_func
 971              		.fpu softvfp
 973              	camera_refresh:
 974              	.LFB67:
 263:hardware/src/grey.c **** 
 264:hardware/src/grey.c **** void camera_refresh(void)
 265:hardware/src/grey.c **** {
 975              		.loc 1 265 1
 976              		.cfi_startproc
 977              		@ args = 0, pretend = 0, frame = 16
 978              		@ frame_needed = 1, uses_anonymous_args = 0
 979 0000 80B5     		push	{r7, lr}
 980              	.LCFI14:
ARM GAS  /tmp/ccBaawNW.s 			page 23


 981              		.cfi_def_cfa_offset 8
 982              		.cfi_offset 7, -8
 983              		.cfi_offset 14, -4
 984 0002 84B0     		sub	sp, sp, #16
 985              	.LCFI15:
 986              		.cfi_def_cfa_offset 24
 987 0004 00AF     		add	r7, sp, #0
 988              	.LCFI16:
 989              		.cfi_def_cfa_register 7
 266:hardware/src/grey.c **** 	u32 i,j;
 267:hardware/src/grey.c ****  	u16 color;	 
 268:hardware/src/grey.c **** 	uint8_t midGrey = 0x58;
 990              		.loc 1 268 10
 991 0006 5823     		movs	r3, #88
 992 0008 FB71     		strb	r3, [r7, #7]
 269:hardware/src/grey.c **** 	if(ov_sta==2)
 993              		.loc 1 269 11
 994 000a 604B     		ldr	r3, .L63
 995 000c 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 996              		.loc 1 269 4
 997 000e 022B     		cmp	r3, #2
 998 0010 40F0B780 		bne	.L62
 270:hardware/src/grey.c **** 	{
 271:hardware/src/grey.c **** 		LCD_Scan_Dir(DFT_SCAN_DIR);	//恢复默认扫描方向 
 999              		.loc 1 271 3
 1000 0014 0020     		movs	r0, #0
 1001 0016 FFF7FEFF 		bl	LCD_Scan_Dir
 272:hardware/src/grey.c **** 		LCD_Set_Window(50,50,120,80);//将显示区域设置到屏幕中央
 1002              		.loc 1 272 3
 1003 001a 5023     		movs	r3, #80
 1004 001c 7822     		movs	r2, #120
 1005 001e 3221     		movs	r1, #50
 1006 0020 3220     		movs	r0, #50
 1007 0022 FFF7FEFF 		bl	LCD_Set_Window
 273:hardware/src/grey.c **** 		LCD_WriteRAM_Prepare();     //开始写入GRAM	
 1008              		.loc 1 273 3
 1009 0026 FFF7FEFF 		bl	LCD_WriteRAM_Prepare
 274:hardware/src/grey.c **** 		OV7670_RRST=0;				//开始复位读指针 
 1010              		.loc 1 274 3
 1011 002a 594B     		ldr	r3, .L63+4
 1012              		.loc 1 274 14
 1013 002c 0022     		movs	r2, #0
 1014 002e 1A60     		str	r2, [r3]
 275:hardware/src/grey.c **** 		OV7670_RCK_L;
 1015              		.loc 1 275 3
 1016 0030 584B     		ldr	r3, .L63+8
 1017 0032 0022     		movs	r2, #0
 1018 0034 1A60     		str	r2, [r3]
 276:hardware/src/grey.c **** 		OV7670_RCK_H;
 1019              		.loc 1 276 3
 1020 0036 574B     		ldr	r3, .L63+8
 1021 0038 0122     		movs	r2, #1
 1022 003a 1A60     		str	r2, [r3]
 277:hardware/src/grey.c **** 		OV7670_RCK_L;
 1023              		.loc 1 277 3
 1024 003c 554B     		ldr	r3, .L63+8
 1025 003e 0022     		movs	r2, #0
ARM GAS  /tmp/ccBaawNW.s 			page 24


 1026 0040 1A60     		str	r2, [r3]
 278:hardware/src/grey.c **** 		OV7670_RRST=1;				//复位读指针结束 
 1027              		.loc 1 278 3
 1028 0042 534B     		ldr	r3, .L63+4
 1029              		.loc 1 278 14
 1030 0044 0122     		movs	r2, #1
 1031 0046 1A60     		str	r2, [r3]
 279:hardware/src/grey.c **** 		OV7670_RCK_H;  
 1032              		.loc 1 279 3
 1033 0048 524B     		ldr	r3, .L63+8
 1034 004a 0122     		movs	r2, #1
 1035 004c 1A60     		str	r2, [r3]
 280:hardware/src/grey.c **** 		for(i=0;i<240;i++){
 1036              		.loc 1 280 8
 1037 004e 0023     		movs	r3, #0
 1038 0050 FB60     		str	r3, [r7, #12]
 1039              		.loc 1 280 3
 1040 0052 60E0     		b	.L50
 1041              	.L55:
 281:hardware/src/grey.c **** 			for(j=0;j<320;j++)
 1042              		.loc 1 281 9
 1043 0054 0023     		movs	r3, #0
 1044 0056 BB60     		str	r3, [r7, #8]
 1045              		.loc 1 281 4
 1046 0058 56E0     		b	.L51
 1047              	.L54:
 282:hardware/src/grey.c **** 			{
 283:hardware/src/grey.c **** 				OV7670_RCK_L;
 1048              		.loc 1 283 5
 1049 005a 4E4B     		ldr	r3, .L63+8
 1050 005c 0022     		movs	r2, #0
 1051 005e 1A60     		str	r2, [r3]
 284:hardware/src/grey.c **** 				color=GPIOF->IDR&0XFF;	//读数据
 1052              		.loc 1 284 16
 1053 0060 4D4B     		ldr	r3, .L63+12
 1054 0062 9B68     		ldr	r3, [r3, #8]
 1055              		.loc 1 284 21
 1056 0064 9BB2     		uxth	r3, r3
 1057              		.loc 1 284 10
 1058 0066 DBB2     		uxtb	r3, r3
 1059 0068 BB80     		strh	r3, [r7, #4]	@ movhi
 285:hardware/src/grey.c **** 				OV7670_RCK_H; 
 1060              		.loc 1 285 5
 1061 006a 4A4B     		ldr	r3, .L63+8
 1062 006c 0122     		movs	r2, #1
 1063 006e 1A60     		str	r2, [r3]
 286:hardware/src/grey.c **** 				color<<=8;  
 1064              		.loc 1 286 10
 1065 0070 BB88     		ldrh	r3, [r7, #4]	@ movhi
 1066 0072 1B02     		lsls	r3, r3, #8
 1067 0074 BB80     		strh	r3, [r7, #4]	@ movhi
 287:hardware/src/grey.c **** 				OV7670_RCK_L;
 1068              		.loc 1 287 5
 1069 0076 474B     		ldr	r3, .L63+8
 1070 0078 0022     		movs	r2, #0
 1071 007a 1A60     		str	r2, [r3]
 288:hardware/src/grey.c **** 				color|=GPIOF->IDR&0XFF;	//读数据
ARM GAS  /tmp/ccBaawNW.s 			page 25


 1072              		.loc 1 288 17
 1073 007c 464B     		ldr	r3, .L63+12
 1074 007e 9B68     		ldr	r3, [r3, #8]
 1075              		.loc 1 288 22
 1076 0080 DBB2     		uxtb	r3, r3
 1077              		.loc 1 288 10
 1078 0082 9AB2     		uxth	r2, r3
 1079 0084 BB88     		ldrh	r3, [r7, #4]	@ movhi
 1080 0086 1343     		orrs	r3, r3, r2
 1081 0088 BB80     		strh	r3, [r7, #4]	@ movhi
 289:hardware/src/grey.c **** 				OV7670_RCK_H; 
 1082              		.loc 1 289 5
 1083 008a 424B     		ldr	r3, .L63+8
 1084 008c 0122     		movs	r2, #1
 1085 008e 1A60     		str	r2, [r3]
 290:hardware/src/grey.c **** 				// LCD->LCD_RAM=color;    
 291:hardware/src/grey.c **** 				if(i%2 == 0){
 1086              		.loc 1 291 9
 1087 0090 FB68     		ldr	r3, [r7, #12]
 1088 0092 03F00103 		and	r3, r3, #1
 1089              		.loc 1 291 7
 1090 0096 002B     		cmp	r3, #0
 1091 0098 33D1     		bne	.L52
 292:hardware/src/grey.c **** 					if(j%4 == 0){
 1092              		.loc 1 292 10
 1093 009a BB68     		ldr	r3, [r7, #8]
 1094 009c 03F00303 		and	r3, r3, #3
 1095              		.loc 1 292 8
 1096 00a0 002B     		cmp	r3, #0
 1097 00a2 2ED1     		bne	.L52
 293:hardware/src/grey.c **** 						color &= 0xff00;
 1098              		.loc 1 293 13
 1099 00a4 BB88     		ldrh	r3, [r7, #4]	@ movhi
 1100 00a6 23F0FF03 		bic	r3, r3, #255
 1101 00aa BB80     		strh	r3, [r7, #4]	@ movhi
 294:hardware/src/grey.c **** 						color >>= 8;
 1102              		.loc 1 294 13
 1103 00ac BB88     		ldrh	r3, [r7, #4]
 1104 00ae 1B0A     		lsrs	r3, r3, #8
 1105 00b0 BB80     		strh	r3, [r7, #4]	@ movhi
 295:hardware/src/grey.c **** 						if((uint8_t)color > midGrey){
 1106              		.loc 1 295 10
 1107 00b2 BB88     		ldrh	r3, [r7, #4]	@ movhi
 1108 00b4 DBB2     		uxtb	r3, r3
 1109              		.loc 1 295 9
 1110 00b6 FA79     		ldrb	r2, [r7, #7]	@ zero_extendqisi2
 1111 00b8 9A42     		cmp	r2, r3
 1112 00ba 11D2     		bcs	.L53
 296:hardware/src/grey.c **** 							// LCD->LCD_RAM=0xffff;
 297:hardware/src/grey.c **** 							cutImg[NEEDHEIGHT-j/4-1][NEEDWITH-i/2-1] = 0xff;
 1113              		.loc 1 297 27
 1114 00bc BB68     		ldr	r3, [r7, #8]
 1115 00be 9B08     		lsrs	r3, r3, #2
 1116              		.loc 1 297 29
 1117 00c0 C3F14F02 		rsb	r2, r3, #79
 1118              		.loc 1 297 43
 1119 00c4 FB68     		ldr	r3, [r7, #12]
ARM GAS  /tmp/ccBaawNW.s 			page 26


 1120 00c6 5B08     		lsrs	r3, r3, #1
 1121              		.loc 1 297 45
 1122 00c8 C3F17701 		rsb	r1, r3, #119
 1123              		.loc 1 297 49
 1124 00cc 3348     		ldr	r0, .L63+16
 1125 00ce 1346     		mov	r3, r2
 1126 00d0 1B01     		lsls	r3, r3, #4
 1127 00d2 9B1A     		subs	r3, r3, r2
 1128 00d4 DB00     		lsls	r3, r3, #3
 1129 00d6 0344     		add	r3, r3, r0
 1130 00d8 0B44     		add	r3, r3, r1
 1131 00da FF22     		movs	r2, #255
 1132 00dc 1A70     		strb	r2, [r3]
 1133 00de 10E0     		b	.L52
 1134              	.L53:
 298:hardware/src/grey.c **** 						}
 299:hardware/src/grey.c **** 						else{
 300:hardware/src/grey.c **** 							// LCD->LCD_RAM=0x0;
 301:hardware/src/grey.c **** 							cutImg[NEEDHEIGHT-j/4-1][NEEDWITH-i/2-1] = 0x0;
 1135              		.loc 1 301 27
 1136 00e0 BB68     		ldr	r3, [r7, #8]
 1137 00e2 9B08     		lsrs	r3, r3, #2
 1138              		.loc 1 301 29
 1139 00e4 C3F14F02 		rsb	r2, r3, #79
 1140              		.loc 1 301 43
 1141 00e8 FB68     		ldr	r3, [r7, #12]
 1142 00ea 5B08     		lsrs	r3, r3, #1
 1143              		.loc 1 301 45
 1144 00ec C3F17701 		rsb	r1, r3, #119
 1145              		.loc 1 301 49
 1146 00f0 2A48     		ldr	r0, .L63+16
 1147 00f2 1346     		mov	r3, r2
 1148 00f4 1B01     		lsls	r3, r3, #4
 1149 00f6 9B1A     		subs	r3, r3, r2
 1150 00f8 DB00     		lsls	r3, r3, #3
 1151 00fa 0344     		add	r3, r3, r0
 1152 00fc 0B44     		add	r3, r3, r1
 1153 00fe 0022     		movs	r2, #0
 1154 0100 1A70     		strb	r2, [r3]
 1155              	.L52:
 281:hardware/src/grey.c **** 			{
 1156              		.loc 1 281 19 discriminator 2
 1157 0102 BB68     		ldr	r3, [r7, #8]
 1158 0104 0133     		adds	r3, r3, #1
 1159 0106 BB60     		str	r3, [r7, #8]
 1160              	.L51:
 281:hardware/src/grey.c **** 			{
 1161              		.loc 1 281 4 discriminator 1
 1162 0108 BB68     		ldr	r3, [r7, #8]
 1163 010a B3F5A07F 		cmp	r3, #320
 1164 010e A4D3     		bcc	.L54
 280:hardware/src/grey.c **** 			for(j=0;j<320;j++)
 1165              		.loc 1 280 18 discriminator 2
 1166 0110 FB68     		ldr	r3, [r7, #12]
 1167 0112 0133     		adds	r3, r3, #1
 1168 0114 FB60     		str	r3, [r7, #12]
 1169              	.L50:
ARM GAS  /tmp/ccBaawNW.s 			page 27


 280:hardware/src/grey.c **** 			for(j=0;j<320;j++)
 1170              		.loc 1 280 3 discriminator 1
 1171 0116 FB68     		ldr	r3, [r7, #12]
 1172 0118 EF2B     		cmp	r3, #239
 1173 011a 9BD9     		bls	.L55
 302:hardware/src/grey.c **** 						}
 303:hardware/src/grey.c **** 					}
 304:hardware/src/grey.c **** 				}
 305:hardware/src/grey.c **** 			}   			
 306:hardware/src/grey.c **** 		}
 307:hardware/src/grey.c **** 		EXTI_ClearITPendingBit(EXTI_Line12);  //清除LINE8上的中断标志位
 1174              		.loc 1 307 3
 1175 011c 4FF48050 		mov	r0, #4096
 1176 0120 FFF7FEFF 		bl	EXTI_ClearITPendingBit
 308:hardware/src/grey.c **** 		ov_sta=0;					//开始下一次采集
 1177              		.loc 1 308 9
 1178 0124 194B     		ldr	r3, .L63
 1179 0126 0022     		movs	r2, #0
 1180 0128 1A70     		strb	r2, [r3]
 309:hardware/src/grey.c ****  		ov_frame++; 
 1181              		.loc 1 309 12
 1182 012a 1D4B     		ldr	r3, .L63+20
 1183 012c 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 1184 012e 0133     		adds	r3, r3, #1
 1185 0130 DAB2     		uxtb	r2, r3
 1186 0132 1B4B     		ldr	r3, .L63+20
 1187 0134 1A70     		strb	r2, [r3]
 310:hardware/src/grey.c **** 		for(i=0;i<NEEDHEIGHT;i++){
 1188              		.loc 1 310 8
 1189 0136 0023     		movs	r3, #0
 1190 0138 FB60     		str	r3, [r7, #12]
 1191              		.loc 1 310 3
 1192 013a 1FE0     		b	.L56
 1193              	.L61:
 311:hardware/src/grey.c **** 			for(j=0;j<NEEDWITH;j++){
 1194              		.loc 1 311 9
 1195 013c 0023     		movs	r3, #0
 1196 013e BB60     		str	r3, [r7, #8]
 1197              		.loc 1 311 4
 1198 0140 16E0     		b	.L57
 1199              	.L60:
 312:hardware/src/grey.c **** 				if(cutImg[i][j] == 0xff)
 1200              		.loc 1 312 17
 1201 0142 1649     		ldr	r1, .L63+16
 1202 0144 FA68     		ldr	r2, [r7, #12]
 1203 0146 1346     		mov	r3, r2
 1204 0148 1B01     		lsls	r3, r3, #4
 1205 014a 9B1A     		subs	r3, r3, r2
 1206 014c DB00     		lsls	r3, r3, #3
 1207 014e CA18     		adds	r2, r1, r3
 1208 0150 BB68     		ldr	r3, [r7, #8]
 1209 0152 1344     		add	r3, r3, r2
 1210 0154 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 1211              		.loc 1 312 7
 1212 0156 FF2B     		cmp	r3, #255
 1213 0158 04D1     		bne	.L58
 313:hardware/src/grey.c **** 					LCD->LCD_RAM=0xffff;
ARM GAS  /tmp/ccBaawNW.s 			page 28


 1214              		.loc 1 313 9
 1215 015a 124B     		ldr	r3, .L63+24
 1216              		.loc 1 313 18
 1217 015c 4FF6FF72 		movw	r2, #65535
 1218 0160 5A80     		strh	r2, [r3, #2]	@ movhi
 1219 0162 02E0     		b	.L59
 1220              	.L58:
 314:hardware/src/grey.c **** 				else
 315:hardware/src/grey.c **** 					LCD->LCD_RAM=0x0;
 1221              		.loc 1 315 9
 1222 0164 0F4B     		ldr	r3, .L63+24
 1223              		.loc 1 315 18
 1224 0166 0022     		movs	r2, #0
 1225 0168 5A80     		strh	r2, [r3, #2]	@ movhi
 1226              	.L59:
 311:hardware/src/grey.c **** 				if(cutImg[i][j] == 0xff)
 1227              		.loc 1 311 24 discriminator 2
 1228 016a BB68     		ldr	r3, [r7, #8]
 1229 016c 0133     		adds	r3, r3, #1
 1230 016e BB60     		str	r3, [r7, #8]
 1231              	.L57:
 311:hardware/src/grey.c **** 				if(cutImg[i][j] == 0xff)
 1232              		.loc 1 311 4 discriminator 1
 1233 0170 BB68     		ldr	r3, [r7, #8]
 1234 0172 772B     		cmp	r3, #119
 1235 0174 E5D9     		bls	.L60
 310:hardware/src/grey.c **** 			for(j=0;j<NEEDWITH;j++){
 1236              		.loc 1 310 25 discriminator 2
 1237 0176 FB68     		ldr	r3, [r7, #12]
 1238 0178 0133     		adds	r3, r3, #1
 1239 017a FB60     		str	r3, [r7, #12]
 1240              	.L56:
 310:hardware/src/grey.c **** 			for(j=0;j<NEEDWITH;j++){
 1241              		.loc 1 310 3 discriminator 1
 1242 017c FB68     		ldr	r3, [r7, #12]
 1243 017e 4F2B     		cmp	r3, #79
 1244 0180 DCD9     		bls	.L61
 1245              	.L62:
 316:hardware/src/grey.c **** 			}
 317:hardware/src/grey.c **** 		}				 
 318:hardware/src/grey.c **** 	} 
 319:hardware/src/grey.c **** }	
 1246              		.loc 1 319 1
 1247 0182 00BF     		nop
 1248 0184 1037     		adds	r7, r7, #16
 1249              	.LCFI17:
 1250              		.cfi_def_cfa_offset 8
 1251 0186 BD46     		mov	sp, r7
 1252              	.LCFI18:
 1253              		.cfi_def_cfa_register 13
 1254              		@ sp needed
 1255 0188 80BD     		pop	{r7, pc}
 1256              	.L64:
 1257 018a 00BF     		.align	2
 1258              	.L63:
 1259 018c 00000000 		.word	ov_sta
 1260 0190 80012342 		.word	1109590400
ARM GAS  /tmp/ccBaawNW.s 			page 29


 1261 0194 90012342 		.word	1109590416
 1262 0198 001C0140 		.word	1073814528
 1263 019c 00000000 		.word	cutImg
 1264 01a0 00000000 		.word	ov_frame
 1265 01a4 FE07006C 		.word	1811941374
 1266              		.cfi_endproc
 1267              	.LFE67:
 1269              		.section	.rodata
 1270 004b 00       		.align	2
 1271              	.LC6:
 1272 004c 4D415820 		.ascii	"MAX Len:%d:----\000"
 1272      4C656E3A 
 1272      25643A2D 
 1272      2D2D2D00 
 1273              		.align	2
 1274              	.LC7:
 1275 005c 25643A25 		.ascii	"%d:%d-%d \000"
 1275      642D2564 
 1275      2000
 1276              		.global	__aeabi_dmul
 1277              		.global	__aeabi_d2iz
 1278 0066 0000     		.align	2
 1279              	.LC8:
 1280 0068 0D0A4B3A 		.ascii	"\015\012K:%d,b:%d\012\000"
 1280      25642C62 
 1280      3A25640A 
 1280      00
 1281              		.section	.text.printToUart,"ax",%progbits
 1282              		.align	1
 1283              		.global	printToUart
 1284              		.syntax unified
 1285              		.thumb
 1286              		.thumb_func
 1287              		.fpu softvfp
 1289              	printToUart:
 1290              	.LFB68:
 320:hardware/src/grey.c **** 
 321:hardware/src/grey.c **** /*调试使用，打印到串口上*/
 322:hardware/src/grey.c **** void printToUart()
 323:hardware/src/grey.c **** {
 1291              		.loc 1 323 1
 1292              		.cfi_startproc
 1293              		@ args = 0, pretend = 0, frame = 8
 1294              		@ frame_needed = 1, uses_anonymous_args = 0
 1295 0000 80B5     		push	{r7, lr}
 1296              	.LCFI19:
 1297              		.cfi_def_cfa_offset 8
 1298              		.cfi_offset 7, -8
 1299              		.cfi_offset 14, -4
 1300 0002 82B0     		sub	sp, sp, #8
 1301              	.LCFI20:
 1302              		.cfi_def_cfa_offset 16
 1303 0004 00AF     		add	r7, sp, #0
 1304              	.LCFI21:
 1305              		.cfi_def_cfa_register 7
 324:hardware/src/grey.c **** 	u8 res;
 325:hardware/src/grey.c **** 	u32 mm;
ARM GAS  /tmp/ccBaawNW.s 			page 30


 326:hardware/src/grey.c **** 	u32 nn;
 327:hardware/src/grey.c ****     u32 i,j;
 328:hardware/src/grey.c **** # if 0
 329:hardware/src/grey.c **** 	printf("\r\n");
 330:hardware/src/grey.c **** 	for(i = 0;i < NEEDHEIGHT;i ++)
 331:hardware/src/grey.c ****     {
 332:hardware/src/grey.c **** 		printf("****");
 333:hardware/src/grey.c **** 		for(j = 0;j < NEEDWITH;j ++)
 334:hardware/src/grey.c **** 		{
 335:hardware/src/grey.c **** 			if(cutImg[i][j] == 0xff)
 336:hardware/src/grey.c **** 			{
 337:hardware/src/grey.c **** 				printf("1");
 338:hardware/src/grey.c **** 			}
 339:hardware/src/grey.c **** 			else
 340:hardware/src/grey.c **** 			{
 341:hardware/src/grey.c **** 				printf("0");
 342:hardware/src/grey.c **** 			}
 343:hardware/src/grey.c **** 				
 344:hardware/src/grey.c **** 		}
 345:hardware/src/grey.c **** 		printf("****\n");
 346:hardware/src/grey.c **** 	}
 347:hardware/src/grey.c **** 	printf("\r\n");
 348:hardware/src/grey.c **** #endif
 349:hardware/src/grey.c **** 	
 350:hardware/src/grey.c **** #if 0
 351:hardware/src/grey.c **** 	/*打印左右边界点*/
 352:hardware/src/grey.c **** 	printf("Left:");
 353:hardware/src/grey.c **** 	for(mm = 0;mm < (NEEDHEIGHT)/(SKIPLINE);mm ++)
 354:hardware/src/grey.c **** 	{
 355:hardware/src/grey.c **** 		printf("%d ",leftBlackLoc[mm]);
 356:hardware/src/grey.c **** 	}
 357:hardware/src/grey.c **** 	printf("\n");
 358:hardware/src/grey.c **** 	printf("******************");
 359:hardware/src/grey.c **** 	printf("\n");
 360:hardware/src/grey.c **** 	printf("Right:");
 361:hardware/src/grey.c **** 	for(nn = 0;nn < (NEEDHEIGHT)/(SKIPLINE);nn ++)
 362:hardware/src/grey.c **** 	{
 363:hardware/src/grey.c **** 		printf("%d ",rightBlackLoc[nn]);
 364:hardware/src/grey.c **** 	}
 365:hardware/src/grey.c **** #endif
 366:hardware/src/grey.c **** 
 367:hardware/src/grey.c **** #if 1
 368:hardware/src/grey.c **** 	printf("MAX Len:%d:----",maxUsefulLineLen);
 1306              		.loc 1 368 2
 1307 0006 1D4B     		ldr	r3, .L68
 1308 0008 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 1309 000a 1946     		mov	r1, r3
 1310 000c 1C48     		ldr	r0, .L68+4
 1311 000e FFF7FEFF 		bl	printf
 369:hardware/src/grey.c **** 	for(nn = 0;nn < maxUsefulLineLen;nn ++)
 1312              		.loc 1 369 9
 1313 0012 0023     		movs	r3, #0
 1314 0014 7B60     		str	r3, [r7, #4]
 1315              		.loc 1 369 2
 1316 0016 10E0     		b	.L66
 1317              	.L67:
 370:hardware/src/grey.c **** 	{
ARM GAS  /tmp/ccBaawNW.s 			page 31


 371:hardware/src/grey.c **** 		printf("%d:%d-%d ",nn,maxUsefulBlackLine[nn],maxUsefulBlackHeight[nn]);
 1318              		.loc 1 371 43 discriminator 3
 1319 0018 1A4A     		ldr	r2, .L68+8
 1320 001a 7B68     		ldr	r3, [r7, #4]
 1321 001c 1344     		add	r3, r3, r2
 1322 001e 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 1323              		.loc 1 371 3 discriminator 3
 1324 0020 1946     		mov	r1, r3
 1325              		.loc 1 371 68 discriminator 3
 1326 0022 194A     		ldr	r2, .L68+12
 1327 0024 7B68     		ldr	r3, [r7, #4]
 1328 0026 1344     		add	r3, r3, r2
 1329 0028 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 1330              		.loc 1 371 3 discriminator 3
 1331 002a 0A46     		mov	r2, r1
 1332 002c 7968     		ldr	r1, [r7, #4]
 1333 002e 1748     		ldr	r0, .L68+16
 1334 0030 FFF7FEFF 		bl	printf
 369:hardware/src/grey.c **** 	for(nn = 0;nn < maxUsefulLineLen;nn ++)
 1335              		.loc 1 369 38 discriminator 3
 1336 0034 7B68     		ldr	r3, [r7, #4]
 1337 0036 0133     		adds	r3, r3, #1
 1338 0038 7B60     		str	r3, [r7, #4]
 1339              	.L66:
 369:hardware/src/grey.c **** 	for(nn = 0;nn < maxUsefulLineLen;nn ++)
 1340              		.loc 1 369 16 discriminator 1
 1341 003a 104B     		ldr	r3, .L68
 1342 003c 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 1343 003e 1A46     		mov	r2, r3
 369:hardware/src/grey.c **** 	for(nn = 0;nn < maxUsefulLineLen;nn ++)
 1344              		.loc 1 369 2 discriminator 1
 1345 0040 7B68     		ldr	r3, [r7, #4]
 1346 0042 9342     		cmp	r3, r2
 1347 0044 E8D3     		bcc	.L67
 372:hardware/src/grey.c **** 	}
 373:hardware/src/grey.c **** 	nn = (int)(1000*overK);
 1348              		.loc 1 373 17
 1349 0046 124B     		ldr	r3, .L68+20
 1350 0048 D3E90001 		ldrd	r0, [r3]
 1351 004c 4FF00002 		mov	r2, #0
 1352 0050 104B     		ldr	r3, .L68+24
 1353 0052 FFF7FEFF 		bl	__aeabi_dmul
 1354 0056 0246     		mov	r2, r0
 1355 0058 0B46     		mov	r3, r1
 1356              		.loc 1 373 7
 1357 005a 1046     		mov	r0, r2
 1358 005c 1946     		mov	r1, r3
 1359 005e FFF7FEFF 		bl	__aeabi_d2iz
 1360 0062 0346     		mov	r3, r0
 1361              		.loc 1 373 5
 1362 0064 7B60     		str	r3, [r7, #4]
 374:hardware/src/grey.c ****     printf("\r\nK:%d,b:%d\n",nn,b);
 1363              		.loc 1 374 5
 1364 0066 0C4B     		ldr	r3, .L68+28
 1365 0068 1B68     		ldr	r3, [r3]
 1366 006a 1A46     		mov	r2, r3
 1367 006c 7968     		ldr	r1, [r7, #4]
ARM GAS  /tmp/ccBaawNW.s 			page 32


 1368 006e 0B48     		ldr	r0, .L68+32
 1369 0070 FFF7FEFF 		bl	printf
 375:hardware/src/grey.c **** #endif		
 376:hardware/src/grey.c **** }
 1370              		.loc 1 376 1
 1371 0074 00BF     		nop
 1372 0076 0837     		adds	r7, r7, #8
 1373              	.LCFI22:
 1374              		.cfi_def_cfa_offset 8
 1375 0078 BD46     		mov	sp, r7
 1376              	.LCFI23:
 1377              		.cfi_def_cfa_register 13
 1378              		@ sp needed
 1379 007a 80BD     		pop	{r7, pc}
 1380              	.L69:
 1381              		.align	2
 1382              	.L68:
 1383 007c 00000000 		.word	maxUsefulLineLen
 1384 0080 4C000000 		.word	.LC6
 1385 0084 00000000 		.word	maxUsefulBlackLine
 1386 0088 00000000 		.word	maxUsefulBlackHeight
 1387 008c 5C000000 		.word	.LC7
 1388 0090 00000000 		.word	overK
 1389 0094 00408F40 		.word	1083129856
 1390 0098 00000000 		.word	b
 1391 009c 68000000 		.word	.LC8
 1392              		.cfi_endproc
 1393              	.LFE68:
 1395              		.section	.text.getLineEdge,"ax",%progbits
 1396              		.align	1
 1397              		.global	getLineEdge
 1398              		.syntax unified
 1399              		.thumb
 1400              		.thumb_func
 1401              		.fpu softvfp
 1403              	getLineEdge:
 1404              	.LFB69:
 377:hardware/src/grey.c **** 
 378:hardware/src/grey.c **** /*
 379:hardware/src/grey.c **** 函数功能：获得黑线的左右侧黑点位置
 380:hardware/src/grey.c **** 参数：供存储黑线左右位置的数组  开始行  结束行  间隔行数
 381:hardware/src/grey.c **** */
 382:hardware/src/grey.c **** void getLineEdge(u8 *leftBlackLoc,u8 *rightBlackLoc,u16 startLine,u16 endLine,u16 skipLine)
 383:hardware/src/grey.c **** {
 1405              		.loc 1 383 1
 1406              		.cfi_startproc
 1407              		@ args = 4, pretend = 0, frame = 24
 1408              		@ frame_needed = 1, uses_anonymous_args = 0
 1409              		@ link register save eliminated.
 1410 0000 90B4     		push	{r4, r7}
 1411              	.LCFI24:
 1412              		.cfi_def_cfa_offset 8
 1413              		.cfi_offset 4, -8
 1414              		.cfi_offset 7, -4
 1415 0002 86B0     		sub	sp, sp, #24
 1416              	.LCFI25:
 1417              		.cfi_def_cfa_offset 32
ARM GAS  /tmp/ccBaawNW.s 			page 33


 1418 0004 00AF     		add	r7, sp, #0
 1419              	.LCFI26:
 1420              		.cfi_def_cfa_register 7
 1421 0006 F860     		str	r0, [r7, #12]
 1422 0008 B960     		str	r1, [r7, #8]
 1423 000a 1146     		mov	r1, r2
 1424 000c 1A46     		mov	r2, r3
 1425 000e 0B46     		mov	r3, r1	@ movhi
 1426 0010 FB80     		strh	r3, [r7, #6]	@ movhi
 1427 0012 1346     		mov	r3, r2	@ movhi
 1428 0014 BB80     		strh	r3, [r7, #4]	@ movhi
 384:hardware/src/grey.c **** 	u16 i = 0;
 1429              		.loc 1 384 6
 1430 0016 0023     		movs	r3, #0
 1431 0018 FB82     		strh	r3, [r7, #22]	@ movhi
 385:hardware/src/grey.c **** 	//u16 j = 0;
 386:hardware/src/grey.c **** 	u16 tmpHeight = 0; 
 1432              		.loc 1 386 6
 1433 001a 0023     		movs	r3, #0
 1434 001c BB82     		strh	r3, [r7, #20]	@ movhi
 387:hardware/src/grey.c **** 	u8 left_loc_get = 0;
 1435              		.loc 1 387 5
 1436 001e 0023     		movs	r3, #0
 1437 0020 FB74     		strb	r3, [r7, #19]
 388:hardware/src/grey.c **** 	u8 right_loc_get = 0;
 1438              		.loc 1 388 5
 1439 0022 0023     		movs	r3, #0
 1440 0024 BB74     		strb	r3, [r7, #18]
 389:hardware/src/grey.c **** #if defined(MAP_TESTA) && MAP_TESTA
 390:hardware/src/grey.c **** 	u8 get_fencha = 0;
 391:hardware/src/grey.c **** 	u8 fencha_start = 0;
 392:hardware/src/grey.c **** #endif
 393:hardware/src/grey.c **** 	FLAG_BORDER = 0;
 1441              		.loc 1 393 14
 1442 0026 764B     		ldr	r3, .L81
 1443 0028 0022     		movs	r2, #0
 1444 002a 1A70     		strb	r2, [r3]
 394:hardware/src/grey.c **** 	
 395:hardware/src/grey.c ****     /*间隔扫描几行*/	
 396:hardware/src/grey.c **** 	for(tmpHeight = startLine;tmpHeight < endLine;tmpHeight += skipLine)
 1445              		.loc 1 396 16
 1446 002c FB88     		ldrh	r3, [r7, #6]	@ movhi
 1447 002e BB82     		strh	r3, [r7, #20]	@ movhi
 1448              		.loc 1 396 2
 1449 0030 DAE0     		b	.L71
 1450              	.L80:
 397:hardware/src/grey.c **** 	{
 398:hardware/src/grey.c **** 		left_loc_get = 0;
 1451              		.loc 1 398 16
 1452 0032 0023     		movs	r3, #0
 1453 0034 FB74     		strb	r3, [r7, #19]
 399:hardware/src/grey.c **** 		right_loc_get = 0;
 1454              		.loc 1 399 17
 1455 0036 0023     		movs	r3, #0
 1456 0038 BB74     		strb	r3, [r7, #18]
 400:hardware/src/grey.c **** #if defined(MAP_TESTA) && MAP_TESTA
 401:hardware/src/grey.c **** 		get_fencha = 0;
ARM GAS  /tmp/ccBaawNW.s 			page 34


 402:hardware/src/grey.c **** #endif
 403:hardware/src/grey.c **** 		/*一行中的检测跳变，每行中就检测一个左点，一个右点*/
 404:hardware/src/grey.c **** 		for(i = 0;i < NEEDWITH - 3;i ++)  //连续判断三个点，所以最后三个点舍去
 1457              		.loc 1 404 9
 1458 003a 0023     		movs	r3, #0
 1459 003c FB82     		strh	r3, [r7, #22]	@ movhi
 1460              		.loc 1 404 3
 1461 003e B9E0     		b	.L72
 1462              	.L77:
 405:hardware/src/grey.c **** 		{
 406:hardware/src/grey.c **** #if defined(MAP_TESTA) && MAP_TESTA
 407:hardware/src/grey.c **** 			if(cutImg[tmpHeight][i] == 0){
 408:hardware/src/grey.c **** 				if(get_fencha == 0)
 409:hardware/src/grey.c **** 					fencha_start = i;
 410:hardware/src/grey.c **** 				get_fencha++;
 411:hardware/src/grey.c **** 			}
 412:hardware/src/grey.c **** #endif
 413:hardware/src/grey.c **** 			if(i==NEEDWITH-4 && cutImg[tmpHeight][NEEDWITH-3]==0 && cutImg[tmpHeight][NEEDWITH-2]==0)
 1463              		.loc 1 413 6
 1464 0040 FB8A     		ldrh	r3, [r7, #22]
 1465 0042 742B     		cmp	r3, #116
 1466 0044 1ED1     		bne	.L73
 1467              		.loc 1 413 41 discriminator 1
 1468 0046 BA8A     		ldrh	r2, [r7, #20]
 1469 0048 6E49     		ldr	r1, .L81+4
 1470 004a 1346     		mov	r3, r2
 1471 004c 1B01     		lsls	r3, r3, #4
 1472 004e 9B1A     		subs	r3, r3, r2
 1473 0050 DB00     		lsls	r3, r3, #3
 1474 0052 0B44     		add	r3, r3, r1
 1475 0054 7533     		adds	r3, r3, #117
 1476 0056 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 1477              		.loc 1 413 21 discriminator 1
 1478 0058 002B     		cmp	r3, #0
 1479 005a 13D1     		bne	.L73
 1480              		.loc 1 413 77 discriminator 2
 1481 005c BA8A     		ldrh	r2, [r7, #20]
 1482 005e 6949     		ldr	r1, .L81+4
 1483 0060 1346     		mov	r3, r2
 1484 0062 1B01     		lsls	r3, r3, #4
 1485 0064 9B1A     		subs	r3, r3, r2
 1486 0066 DB00     		lsls	r3, r3, #3
 1487 0068 0B44     		add	r3, r3, r1
 1488 006a 7633     		adds	r3, r3, #118
 1489 006c 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 1490              		.loc 1 413 57 discriminator 2
 1491 006e 002B     		cmp	r3, #0
 1492 0070 08D1     		bne	.L73
 414:hardware/src/grey.c **** 			{
 415:hardware/src/grey.c **** 				right_loc_get = 1;
 1493              		.loc 1 415 19
 1494 0072 0123     		movs	r3, #1
 1495 0074 BB74     		strb	r3, [r7, #18]
 416:hardware/src/grey.c **** 				*rightBlackLoc = NEEDWITH-2;
 1496              		.loc 1 416 20
 1497 0076 BB68     		ldr	r3, [r7, #8]
 1498 0078 7622     		movs	r2, #118
ARM GAS  /tmp/ccBaawNW.s 			page 35


 1499 007a 1A70     		strb	r2, [r3]
 417:hardware/src/grey.c **** 				FLAG_BORDER = 2;
 1500              		.loc 1 417 17
 1501 007c 604B     		ldr	r3, .L81
 1502 007e 0222     		movs	r2, #2
 1503 0080 1A70     		strb	r2, [r3]
 1504 0082 39E0     		b	.L74
 1505              	.L73:
 418:hardware/src/grey.c **** 			}
 419:hardware/src/grey.c **** 				/*检测到正跳变，紧接着就是相同的高电平，那么就是右边的黑色点被检测到了 i+1就是黑点的位置*/
 420:hardware/src/grey.c **** 			else if(  ((cutImg[tmpHeight][i] - cutImg[tmpHeight][i+1] ) <= UPJUMP) && 
 1506              		.loc 1 420 33
 1507 0084 BA8A     		ldrh	r2, [r7, #20]
 1508 0086 F98A     		ldrh	r1, [r7, #22]
 1509 0088 5E48     		ldr	r0, .L81+4
 1510 008a 1346     		mov	r3, r2
 1511 008c 1B01     		lsls	r3, r3, #4
 1512 008e 9B1A     		subs	r3, r3, r2
 1513 0090 DB00     		lsls	r3, r3, #3
 1514 0092 0344     		add	r3, r3, r0
 1515 0094 0B44     		add	r3, r3, r1
 1516 0096 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 1517 0098 1C46     		mov	r4, r3
 1518              		.loc 1 420 56
 1519 009a BA8A     		ldrh	r2, [r7, #20]
 1520              		.loc 1 420 58
 1521 009c FB8A     		ldrh	r3, [r7, #22]
 1522 009e 591C     		adds	r1, r3, #1
 1523              		.loc 1 420 56
 1524 00a0 5848     		ldr	r0, .L81+4
 1525 00a2 1346     		mov	r3, r2
 1526 00a4 1B01     		lsls	r3, r3, #4
 1527 00a6 9B1A     		subs	r3, r3, r2
 1528 00a8 DB00     		lsls	r3, r3, #3
 1529 00aa 0344     		add	r3, r3, r0
 1530 00ac 0B44     		add	r3, r3, r1
 1531 00ae 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 1532              		.loc 1 420 37
 1533 00b0 E31A     		subs	r3, r4, r3
 1534              		.loc 1 420 11
 1535 00b2 13F1FD0F 		cmn	r3, #253
 1536 00b6 1FDA     		bge	.L74
 421:hardware/src/grey.c **** 					(cutImg[tmpHeight][i+1] == cutImg[tmpHeight][i+2])  )
 1537              		.loc 1 421 24 discriminator 1
 1538 00b8 BA8A     		ldrh	r2, [r7, #20]
 1539              		.loc 1 421 26 discriminator 1
 1540 00ba FB8A     		ldrh	r3, [r7, #22]
 1541 00bc 591C     		adds	r1, r3, #1
 1542              		.loc 1 421 24 discriminator 1
 1543 00be 5148     		ldr	r0, .L81+4
 1544 00c0 1346     		mov	r3, r2
 1545 00c2 1B01     		lsls	r3, r3, #4
 1546 00c4 9B1A     		subs	r3, r3, r2
 1547 00c6 DB00     		lsls	r3, r3, #3
 1548 00c8 0344     		add	r3, r3, r0
 1549 00ca 0B44     		add	r3, r3, r1
 1550 00cc 1978     		ldrb	r1, [r3]	@ zero_extendqisi2
ARM GAS  /tmp/ccBaawNW.s 			page 36


 1551              		.loc 1 421 50 discriminator 1
 1552 00ce BA8A     		ldrh	r2, [r7, #20]
 1553              		.loc 1 421 52 discriminator 1
 1554 00d0 FB8A     		ldrh	r3, [r7, #22]
 1555 00d2 981C     		adds	r0, r3, #2
 1556              		.loc 1 421 50 discriminator 1
 1557 00d4 4B4C     		ldr	r4, .L81+4
 1558 00d6 1346     		mov	r3, r2
 1559 00d8 1B01     		lsls	r3, r3, #4
 1560 00da 9B1A     		subs	r3, r3, r2
 1561 00dc DB00     		lsls	r3, r3, #3
 1562 00de 2344     		add	r3, r3, r4
 1563 00e0 0344     		add	r3, r3, r0
 1564 00e2 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 420:hardware/src/grey.c **** 					(cutImg[tmpHeight][i+1] == cutImg[tmpHeight][i+2])  )
 1565              		.loc 1 420 75 discriminator 1
 1566 00e4 9942     		cmp	r1, r3
 1567 00e6 07D1     		bne	.L74
 422:hardware/src/grey.c **** 			{
 423:hardware/src/grey.c **** 				right_loc_get = 1;
 1568              		.loc 1 423 19
 1569 00e8 0123     		movs	r3, #1
 1570 00ea BB74     		strb	r3, [r7, #18]
 424:hardware/src/grey.c **** 				*rightBlackLoc = i+1;
 1571              		.loc 1 424 23
 1572 00ec FB8A     		ldrh	r3, [r7, #22]	@ movhi
 1573 00ee DBB2     		uxtb	r3, r3
 1574 00f0 0133     		adds	r3, r3, #1
 1575 00f2 DAB2     		uxtb	r2, r3
 1576              		.loc 1 424 20
 1577 00f4 BB68     		ldr	r3, [r7, #8]
 1578 00f6 1A70     		strb	r2, [r3]
 1579              	.L74:
 425:hardware/src/grey.c **** 			}
 426:hardware/src/grey.c **** 
 427:hardware/src/grey.c **** 			if(i==0 && cutImg[tmpHeight][1]==0 && cutImg[tmpHeight][2]==0)
 1580              		.loc 1 427 6
 1581 00f8 FB8A     		ldrh	r3, [r7, #22]
 1582 00fa 002B     		cmp	r3, #0
 1583 00fc 1ED1     		bne	.L75
 1584              		.loc 1 427 32 discriminator 1
 1585 00fe BA8A     		ldrh	r2, [r7, #20]
 1586 0100 4049     		ldr	r1, .L81+4
 1587 0102 1346     		mov	r3, r2
 1588 0104 1B01     		lsls	r3, r3, #4
 1589 0106 9B1A     		subs	r3, r3, r2
 1590 0108 DB00     		lsls	r3, r3, #3
 1591 010a 0B44     		add	r3, r3, r1
 1592 010c 0133     		adds	r3, r3, #1
 1593 010e 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 1594              		.loc 1 427 12 discriminator 1
 1595 0110 002B     		cmp	r3, #0
 1596 0112 13D1     		bne	.L75
 1597              		.loc 1 427 59 discriminator 2
 1598 0114 BA8A     		ldrh	r2, [r7, #20]
 1599 0116 3B49     		ldr	r1, .L81+4
 1600 0118 1346     		mov	r3, r2
ARM GAS  /tmp/ccBaawNW.s 			page 37


 1601 011a 1B01     		lsls	r3, r3, #4
 1602 011c 9B1A     		subs	r3, r3, r2
 1603 011e DB00     		lsls	r3, r3, #3
 1604 0120 0B44     		add	r3, r3, r1
 1605 0122 0233     		adds	r3, r3, #2
 1606 0124 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 1607              		.loc 1 427 39 discriminator 2
 1608 0126 002B     		cmp	r3, #0
 1609 0128 08D1     		bne	.L75
 428:hardware/src/grey.c **** 			{
 429:hardware/src/grey.c **** 				left_loc_get = 1;
 1610              		.loc 1 429 18
 1611 012a 0123     		movs	r3, #1
 1612 012c FB74     		strb	r3, [r7, #19]
 430:hardware/src/grey.c **** 				*leftBlackLoc = 1;
 1613              		.loc 1 430 19
 1614 012e FB68     		ldr	r3, [r7, #12]
 1615 0130 0122     		movs	r2, #1
 1616 0132 1A70     		strb	r2, [r3]
 431:hardware/src/grey.c **** 				FLAG_BORDER = 1;
 1617              		.loc 1 431 17
 1618 0134 324B     		ldr	r3, .L81
 1619 0136 0122     		movs	r2, #1
 1620 0138 1A70     		strb	r2, [r3]
 1621 013a 38E0     		b	.L76
 1622              	.L75:
 432:hardware/src/grey.c **** 			}
 433:hardware/src/grey.c **** 			/*检测到负跳变，紧接着就是相同的低电平，那么就是左侧的黑点被检测到了 i+1就是黑点的位置*/
 434:hardware/src/grey.c **** 			else if( (cutImg[tmpHeight][i] - cutImg[tmpHeight][i+1] ) >= DOWNJUMP && 
 1623              		.loc 1 434 31
 1624 013c BA8A     		ldrh	r2, [r7, #20]
 1625 013e F98A     		ldrh	r1, [r7, #22]
 1626 0140 3048     		ldr	r0, .L81+4
 1627 0142 1346     		mov	r3, r2
 1628 0144 1B01     		lsls	r3, r3, #4
 1629 0146 9B1A     		subs	r3, r3, r2
 1630 0148 DB00     		lsls	r3, r3, #3
 1631 014a 0344     		add	r3, r3, r0
 1632 014c 0B44     		add	r3, r3, r1
 1633 014e 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 1634 0150 1C46     		mov	r4, r3
 1635              		.loc 1 434 54
 1636 0152 BA8A     		ldrh	r2, [r7, #20]
 1637              		.loc 1 434 56
 1638 0154 FB8A     		ldrh	r3, [r7, #22]
 1639 0156 591C     		adds	r1, r3, #1
 1640              		.loc 1 434 54
 1641 0158 2A48     		ldr	r0, .L81+4
 1642 015a 1346     		mov	r3, r2
 1643 015c 1B01     		lsls	r3, r3, #4
 1644 015e 9B1A     		subs	r3, r3, r2
 1645 0160 DB00     		lsls	r3, r3, #3
 1646 0162 0344     		add	r3, r3, r0
 1647 0164 0B44     		add	r3, r3, r1
 1648 0166 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 1649              		.loc 1 434 35
 1650 0168 E31A     		subs	r3, r4, r3
ARM GAS  /tmp/ccBaawNW.s 			page 38


 1651              		.loc 1 434 11
 1652 016a FD2B     		cmp	r3, #253
 1653 016c 1FDD     		ble	.L76
 435:hardware/src/grey.c **** 					((cutImg[tmpHeight][i+1] == cutImg[tmpHeight][i+2])) )
 1654              		.loc 1 435 25 discriminator 1
 1655 016e BA8A     		ldrh	r2, [r7, #20]
 1656              		.loc 1 435 27 discriminator 1
 1657 0170 FB8A     		ldrh	r3, [r7, #22]
 1658 0172 591C     		adds	r1, r3, #1
 1659              		.loc 1 435 25 discriminator 1
 1660 0174 2348     		ldr	r0, .L81+4
 1661 0176 1346     		mov	r3, r2
 1662 0178 1B01     		lsls	r3, r3, #4
 1663 017a 9B1A     		subs	r3, r3, r2
 1664 017c DB00     		lsls	r3, r3, #3
 1665 017e 0344     		add	r3, r3, r0
 1666 0180 0B44     		add	r3, r3, r1
 1667 0182 1978     		ldrb	r1, [r3]	@ zero_extendqisi2
 1668              		.loc 1 435 51 discriminator 1
 1669 0184 BA8A     		ldrh	r2, [r7, #20]
 1670              		.loc 1 435 53 discriminator 1
 1671 0186 FB8A     		ldrh	r3, [r7, #22]
 1672 0188 981C     		adds	r0, r3, #2
 1673              		.loc 1 435 51 discriminator 1
 1674 018a 1E4C     		ldr	r4, .L81+4
 1675 018c 1346     		mov	r3, r2
 1676 018e 1B01     		lsls	r3, r3, #4
 1677 0190 9B1A     		subs	r3, r3, r2
 1678 0192 DB00     		lsls	r3, r3, #3
 1679 0194 2344     		add	r3, r3, r4
 1680 0196 0344     		add	r3, r3, r0
 1681 0198 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 434:hardware/src/grey.c **** 					((cutImg[tmpHeight][i+1] == cutImg[tmpHeight][i+2])) )
 1682              		.loc 1 434 74 discriminator 1
 1683 019a 9942     		cmp	r1, r3
 1684 019c 07D1     		bne	.L76
 436:hardware/src/grey.c **** 			//存储左黑点的位置
 437:hardware/src/grey.c **** 			{
 438:hardware/src/grey.c **** 				left_loc_get = 1;
 1685              		.loc 1 438 18
 1686 019e 0123     		movs	r3, #1
 1687 01a0 FB74     		strb	r3, [r7, #19]
 439:hardware/src/grey.c **** 				*leftBlackLoc = i+1;
 1688              		.loc 1 439 22
 1689 01a2 FB8A     		ldrh	r3, [r7, #22]	@ movhi
 1690 01a4 DBB2     		uxtb	r3, r3
 1691 01a6 0133     		adds	r3, r3, #1
 1692 01a8 DAB2     		uxtb	r2, r3
 1693              		.loc 1 439 19
 1694 01aa FB68     		ldr	r3, [r7, #12]
 1695 01ac 1A70     		strb	r2, [r3]
 1696              	.L76:
 404:hardware/src/grey.c **** 		{
 1697              		.loc 1 404 32 discriminator 2
 1698 01ae FB8A     		ldrh	r3, [r7, #22]
 1699 01b0 0133     		adds	r3, r3, #1
 1700 01b2 FB82     		strh	r3, [r7, #22]	@ movhi
ARM GAS  /tmp/ccBaawNW.s 			page 39


 1701              	.L72:
 404:hardware/src/grey.c **** 		{
 1702              		.loc 1 404 3 discriminator 1
 1703 01b4 FB8A     		ldrh	r3, [r7, #22]
 1704 01b6 742B     		cmp	r3, #116
 1705 01b8 7FF642AF 		bls	.L77
 440:hardware/src/grey.c **** 			}
 441:hardware/src/grey.c **** 		}
 442:hardware/src/grey.c **** 		if(left_loc_get == 0){
 1706              		.loc 1 442 5
 1707 01bc FB7C     		ldrb	r3, [r7, #19]	@ zero_extendqisi2
 1708 01be 002B     		cmp	r3, #0
 1709 01c0 02D1     		bne	.L78
 443:hardware/src/grey.c **** 			*leftBlackLoc = 0;
 1710              		.loc 1 443 18
 1711 01c2 FB68     		ldr	r3, [r7, #12]
 1712 01c4 0022     		movs	r2, #0
 1713 01c6 1A70     		strb	r2, [r3]
 1714              	.L78:
 444:hardware/src/grey.c **** 		}
 445:hardware/src/grey.c **** 		if(right_loc_get == 0){
 1715              		.loc 1 445 5
 1716 01c8 BB7C     		ldrb	r3, [r7, #18]	@ zero_extendqisi2
 1717 01ca 002B     		cmp	r3, #0
 1718 01cc 02D1     		bne	.L79
 446:hardware/src/grey.c **** 			*rightBlackLoc = 0;
 1719              		.loc 1 446 19
 1720 01ce BB68     		ldr	r3, [r7, #8]
 1721 01d0 0022     		movs	r2, #0
 1722 01d2 1A70     		strb	r2, [r3]
 1723              	.L79:
 447:hardware/src/grey.c **** 		}
 448:hardware/src/grey.c **** 			//准备下一行
 449:hardware/src/grey.c **** 		rightBlackLoc ++;leftBlackLoc  ++;				
 1724              		.loc 1 449 17 discriminator 2
 1725 01d4 BB68     		ldr	r3, [r7, #8]
 1726 01d6 0133     		adds	r3, r3, #1
 1727 01d8 BB60     		str	r3, [r7, #8]
 1728              		.loc 1 449 34 discriminator 2
 1729 01da FB68     		ldr	r3, [r7, #12]
 1730 01dc 0133     		adds	r3, r3, #1
 1731 01de FB60     		str	r3, [r7, #12]
 396:hardware/src/grey.c **** 	{
 1732              		.loc 1 396 58 discriminator 2
 1733 01e0 BA8A     		ldrh	r2, [r7, #20]	@ movhi
 1734 01e2 3B8C     		ldrh	r3, [r7, #32]	@ movhi
 1735 01e4 1344     		add	r3, r3, r2
 1736 01e6 BB82     		strh	r3, [r7, #20]	@ movhi
 1737              	.L71:
 396:hardware/src/grey.c **** 	{
 1738              		.loc 1 396 2 discriminator 1
 1739 01e8 BA8A     		ldrh	r2, [r7, #20]
 1740 01ea BB88     		ldrh	r3, [r7, #4]
 1741 01ec 9A42     		cmp	r2, r3
 1742 01ee FFF420AF 		bcc	.L80
 450:hardware/src/grey.c **** #if defined(MAP_TESTA) && MAP_TESTA
 451:hardware/src/grey.c **** 		if(get_fencha > max_black_fencha){
ARM GAS  /tmp/ccBaawNW.s 			page 40


 452:hardware/src/grey.c **** 			fencha_times++;
 453:hardware/src/grey.c **** 			if(fencha_times < 5){
 454:hardware/src/grey.c **** 				move_for_fencha(fencha_times);
 455:hardware/src/grey.c **** 				if(fencha_times == 5)
 456:hardware/src/grey.c **** 					RUNNING = 0;
 457:hardware/src/grey.c **** 				if(fencha_start <= 20)
 458:hardware/src/grey.c **** 					printStopMess(5);
 459:hardware/src/grey.c **** 				else
 460:hardware/src/grey.c **** 					printStopMess(6);
 461:hardware/src/grey.c **** 				break;
 462:hardware/src/grey.c **** 			}
 463:hardware/src/grey.c **** 		}
 464:hardware/src/grey.c **** #endif
 465:hardware/src/grey.c **** 	}
 466:hardware/src/grey.c **** }
 1743              		.loc 1 466 1
 1744 01f2 00BF     		nop
 1745 01f4 00BF     		nop
 1746 01f6 1837     		adds	r7, r7, #24
 1747              	.LCFI27:
 1748              		.cfi_def_cfa_offset 8
 1749 01f8 BD46     		mov	sp, r7
 1750              	.LCFI28:
 1751              		.cfi_def_cfa_register 13
 1752              		@ sp needed
 1753 01fa 90BC     		pop	{r4, r7}
 1754              	.LCFI29:
 1755              		.cfi_restore 7
 1756              		.cfi_restore 4
 1757              		.cfi_def_cfa_offset 0
 1758 01fc 7047     		bx	lr
 1759              	.L82:
 1760 01fe 00BF     		.align	2
 1761              	.L81:
 1762 0200 00000000 		.word	FLAG_BORDER
 1763 0204 00000000 		.word	cutImg
 1764              		.cfi_endproc
 1765              	.LFE69:
 1767              		.section	.text.getOneSideUsefulLine,"ax",%progbits
 1768              		.align	1
 1769              		.global	getOneSideUsefulLine
 1770              		.syntax unified
 1771              		.thumb
 1772              		.thumb_func
 1773              		.fpu softvfp
 1775              	getOneSideUsefulLine:
 1776              	.LFB70:
 467:hardware/src/grey.c **** 
 468:hardware/src/grey.c **** // /*将获取有效段的函数部分进行复用*/
 469:hardware/src/grey.c **** // //参数分别是 原始段  段前0的个数  存储最长有效段的位置数组  存储最长长度  存储最长有效段的高度位
 470:hardware/src/grey.c **** void getOneSideUsefulLine(u8 *needBlackLoc,u8 countZero,u8 *maxUBlackLine,u8 *maxUBlackLineLen,u8 *
 471:hardware/src/grey.c **** {
 1777              		.loc 1 471 1
 1778              		.cfi_startproc
 1779              		@ args = 4, pretend = 0, frame = 72
 1780              		@ frame_needed = 1, uses_anonymous_args = 0
 1781 0000 80B5     		push	{r7, lr}
ARM GAS  /tmp/ccBaawNW.s 			page 41


 1782              	.LCFI30:
 1783              		.cfi_def_cfa_offset 8
 1784              		.cfi_offset 7, -8
 1785              		.cfi_offset 14, -4
 1786 0002 92B0     		sub	sp, sp, #72
 1787              	.LCFI31:
 1788              		.cfi_def_cfa_offset 80
 1789 0004 00AF     		add	r7, sp, #0
 1790              	.LCFI32:
 1791              		.cfi_def_cfa_register 7
 1792 0006 F860     		str	r0, [r7, #12]
 1793 0008 7A60     		str	r2, [r7, #4]
 1794 000a 3B60     		str	r3, [r7]
 1795 000c 0B46     		mov	r3, r1
 1796 000e FB72     		strb	r3, [r7, #11]
 472:hardware/src/grey.c **** 	int i = 0;
 1797              		.loc 1 472 6
 1798 0010 0023     		movs	r3, #0
 1799 0012 7B64     		str	r3, [r7, #68]
 473:hardware/src/grey.c **** 	int j = 0;
 1800              		.loc 1 473 6
 1801 0014 0023     		movs	r3, #0
 1802 0016 3B64     		str	r3, [r7, #64]
 474:hardware/src/grey.c **** 	/*截取最长段的临时存储变量*/
 475:hardware/src/grey.c **** 	u8 tmpMaxUsefulLineLen = 0;//实时保存当前最长的段长度
 1803              		.loc 1 475 5
 1804 0018 0023     		movs	r3, #0
 1805 001a 87F83F30 		strb	r3, [r7, #63]
 476:hardware/src/grey.c **** 	u8 tmpMaxUsefulLine[(NEEDHEIGHT)/(SKIPLINE)]  = {0}; //用于保存有效的最长段
 1806              		.loc 1 476 5
 1807 001e 0023     		movs	r3, #0
 1808 0020 BB62     		str	r3, [r7, #40]
 1809 0022 07F12C03 		add	r3, r7, #44
 1810 0026 0022     		movs	r2, #0
 1811 0028 1A60     		str	r2, [r3]
 1812 002a 5A60     		str	r2, [r3, #4]
 1813 002c 9A60     		str	r2, [r3, #8]
 1814 002e DA60     		str	r2, [r3, #12]
 477:hardware/src/grey.c **** 	u8 tmpmaxUBlackHeight[(NEEDHEIGHT)/(SKIPLINE)] = {0};//保存高度
 1815              		.loc 1 477 5
 1816 0030 0023     		movs	r3, #0
 1817 0032 7B61     		str	r3, [r7, #20]
 1818 0034 07F11803 		add	r3, r7, #24
 1819 0038 0022     		movs	r2, #0
 1820 003a 1A60     		str	r2, [r3]
 1821 003c 5A60     		str	r2, [r3, #4]
 1822 003e 9A60     		str	r2, [r3, #8]
 1823 0040 DA60     		str	r2, [r3, #12]
 478:hardware/src/grey.c **** 	*maxUBlackLineLen = 0;
 1824              		.loc 1 478 20
 1825 0042 3B68     		ldr	r3, [r7]
 1826 0044 0022     		movs	r2, #0
 1827 0046 1A70     		strb	r2, [r3]
 479:hardware/src/grey.c **** 	//从左边第一个有效的地方往后检测，直到最后
 480:hardware/src/grey.c **** 	for(i = countZero;i < (NEEDHEIGHT)/(SKIPLINE) - 2;i ++)
 1828              		.loc 1 480 8
 1829 0048 FB7A     		ldrb	r3, [r7, #11]	@ zero_extendqisi2
ARM GAS  /tmp/ccBaawNW.s 			page 42


 1830 004a 7B64     		str	r3, [r7, #68]
 1831              		.loc 1 480 2
 1832 004c C5E0     		b	.L84
 1833              	.L94:
 481:hardware/src/grey.c **** 	{
 482:hardware/src/grey.c **** 		/*
 483:hardware/src/grey.c **** 			如果第三个位置，直接就是0，那么认为这一段就要采集结束了，
 484:hardware/src/grey.c **** 			将临时的段存储到全局的变量中
 485:hardware/src/grey.c **** 		*/
 486:hardware/src/grey.c **** 		if(needBlackLoc[i+2] == 0)//一段采集结束
 1834              		.loc 1 486 18
 1835 004e 7B6C     		ldr	r3, [r7, #68]
 1836 0050 0233     		adds	r3, r3, #2
 1837 0052 FA68     		ldr	r2, [r7, #12]
 1838 0054 1344     		add	r3, r3, r2
 1839 0056 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 1840              		.loc 1 486 5
 1841 0058 002B     		cmp	r3, #0
 1842 005a 55D1     		bne	.L85
 487:hardware/src/grey.c **** 		{
 488:hardware/src/grey.c **** 			//如果段比较长的话，才选中
 489:hardware/src/grey.c **** 			if((*maxUBlackLineLen) < tmpMaxUsefulLineLen)
 1843              		.loc 1 489 8
 1844 005c 3B68     		ldr	r3, [r7]
 1845 005e 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 1846              		.loc 1 489 6
 1847 0060 97F83F20 		ldrb	r2, [r7, #63]	@ zero_extendqisi2
 1848 0064 9A42     		cmp	r2, r3
 1849 0066 2AD9     		bls	.L86
 490:hardware/src/grey.c **** 			{
 491:hardware/src/grey.c **** 				//存储
 492:hardware/src/grey.c **** 				(*maxUBlackLineLen) = tmpMaxUsefulLineLen;
 1850              		.loc 1 492 25
 1851 0068 3B68     		ldr	r3, [r7]
 1852 006a 97F83F20 		ldrb	r2, [r7, #63]
 1853 006e 1A70     		strb	r2, [r3]
 493:hardware/src/grey.c **** 				memset(maxUBlackLine,0,(NEEDHEIGHT)/(SKIPLINE));//清空以备存储
 1854              		.loc 1 493 5
 1855 0070 1422     		movs	r2, #20
 1856 0072 0021     		movs	r1, #0
 1857 0074 7868     		ldr	r0, [r7, #4]
 1858 0076 FFF7FEFF 		bl	memset
 494:hardware/src/grey.c **** 				memset(maxUBlackHeight,0,(NEEDHEIGHT)/(SKIPLINE));
 1859              		.loc 1 494 5
 1860 007a 1422     		movs	r2, #20
 1861 007c 0021     		movs	r1, #0
 1862 007e 386D     		ldr	r0, [r7, #80]
 1863 0080 FFF7FEFF 		bl	memset
 495:hardware/src/grey.c **** 				for(j = 0;j <= tmpMaxUsefulLineLen;j ++)
 1864              		.loc 1 495 11
 1865 0084 0023     		movs	r3, #0
 1866 0086 3B64     		str	r3, [r7, #64]
 1867              		.loc 1 495 5
 1868 0088 14E0     		b	.L87
 1869              	.L88:
 496:hardware/src/grey.c **** 				{
 497:hardware/src/grey.c **** 					maxUBlackLine[j] = tmpMaxUsefulLine[j];
ARM GAS  /tmp/ccBaawNW.s 			page 43


 1870              		.loc 1 497 19 discriminator 3
 1871 008a 3B6C     		ldr	r3, [r7, #64]
 1872 008c 7A68     		ldr	r2, [r7, #4]
 1873 008e 1344     		add	r3, r3, r2
 1874              		.loc 1 497 41 discriminator 3
 1875 0090 07F12801 		add	r1, r7, #40
 1876 0094 3A6C     		ldr	r2, [r7, #64]
 1877 0096 0A44     		add	r2, r2, r1
 1878 0098 1278     		ldrb	r2, [r2]	@ zero_extendqisi2
 1879              		.loc 1 497 23 discriminator 3
 1880 009a 1A70     		strb	r2, [r3]
 498:hardware/src/grey.c **** 					maxUBlackHeight[j] = tmpmaxUBlackHeight[j];//存储高度
 1881              		.loc 1 498 21 discriminator 3
 1882 009c 3B6C     		ldr	r3, [r7, #64]
 1883 009e 3A6D     		ldr	r2, [r7, #80]
 1884 00a0 1344     		add	r3, r3, r2
 1885              		.loc 1 498 45 discriminator 3
 1886 00a2 07F11401 		add	r1, r7, #20
 1887 00a6 3A6C     		ldr	r2, [r7, #64]
 1888 00a8 0A44     		add	r2, r2, r1
 1889 00aa 1278     		ldrb	r2, [r2]	@ zero_extendqisi2
 1890              		.loc 1 498 25 discriminator 3
 1891 00ac 1A70     		strb	r2, [r3]
 495:hardware/src/grey.c **** 				for(j = 0;j <= tmpMaxUsefulLineLen;j ++)
 1892              		.loc 1 495 42 discriminator 3
 1893 00ae 3B6C     		ldr	r3, [r7, #64]
 1894 00b0 0133     		adds	r3, r3, #1
 1895 00b2 3B64     		str	r3, [r7, #64]
 1896              	.L87:
 495:hardware/src/grey.c **** 				for(j = 0;j <= tmpMaxUsefulLineLen;j ++)
 1897              		.loc 1 495 17 discriminator 1
 1898 00b4 97F83F30 		ldrb	r3, [r7, #63]	@ zero_extendqisi2
 495:hardware/src/grey.c **** 				for(j = 0;j <= tmpMaxUsefulLineLen;j ++)
 1899              		.loc 1 495 5 discriminator 1
 1900 00b8 3A6C     		ldr	r2, [r7, #64]
 1901 00ba 9A42     		cmp	r2, r3
 1902 00bc E5DD     		ble	.L88
 1903              	.L86:
 499:hardware/src/grey.c **** 				}
 500:hardware/src/grey.c **** 			}
 501:hardware/src/grey.c **** 			//存完清空
 502:hardware/src/grey.c **** 			memset(tmpMaxUsefulLine,0,(NEEDHEIGHT)/(SKIPLINE));
 1904              		.loc 1 502 4
 1905 00be 07F12803 		add	r3, r7, #40
 1906 00c2 1422     		movs	r2, #20
 1907 00c4 0021     		movs	r1, #0
 1908 00c6 1846     		mov	r0, r3
 1909 00c8 FFF7FEFF 		bl	memset
 503:hardware/src/grey.c **** 			memset(tmpmaxUBlackHeight,0,(NEEDHEIGHT)/(SKIPLINE));
 1910              		.loc 1 503 4
 1911 00cc 07F11403 		add	r3, r7, #20
 1912 00d0 1422     		movs	r2, #20
 1913 00d2 0021     		movs	r1, #0
 1914 00d4 1846     		mov	r0, r3
 1915 00d6 FFF7FEFF 		bl	memset
 504:hardware/src/grey.c **** 			tmpMaxUsefulLineLen = 0;
 1916              		.loc 1 504 24
ARM GAS  /tmp/ccBaawNW.s 			page 44


 1917 00da 0023     		movs	r3, #0
 1918 00dc 87F83F30 		strb	r3, [r7, #63]
 505:hardware/src/grey.c **** 			/*结束*/
 506:hardware/src/grey.c **** 			//将i+2以及后续有0的位置全部跳过
 507:hardware/src/grey.c **** 			if((i + 3) < (NEEDHEIGHT)/(SKIPLINE))//放置越界
 1919              		.loc 1 507 6
 1920 00e0 7B6C     		ldr	r3, [r7, #68]
 1921 00e2 102B     		cmp	r3, #16
 1922 00e4 06DC     		bgt	.L90
 508:hardware/src/grey.c **** 			{
 509:hardware/src/grey.c **** 				i += 3;//从i + 3位置开始
 1923              		.loc 1 509 7
 1924 00e6 7B6C     		ldr	r3, [r7, #68]
 1925 00e8 0333     		adds	r3, r3, #3
 1926 00ea 7B64     		str	r3, [r7, #68]
 510:hardware/src/grey.c **** 			}
 511:hardware/src/grey.c **** 			/*未到最后第三个，并且一直为0，那么就继续*/
 512:hardware/src/grey.c **** 			while((i < ((NEEDHEIGHT)/(SKIPLINE) - 2)) && (needBlackLoc[i] == 0))
 1927              		.loc 1 512 9
 1928 00ec 02E0     		b	.L90
 1929              	.L92:
 513:hardware/src/grey.c **** 			{
 514:hardware/src/grey.c **** 				i ++;
 1930              		.loc 1 514 7
 1931 00ee 7B6C     		ldr	r3, [r7, #68]
 1932 00f0 0133     		adds	r3, r3, #1
 1933 00f2 7B64     		str	r3, [r7, #68]
 1934              	.L90:
 512:hardware/src/grey.c **** 			{
 1935              		.loc 1 512 9
 1936 00f4 7B6C     		ldr	r3, [r7, #68]
 1937 00f6 112B     		cmp	r3, #17
 1938 00f8 6BDC     		bgt	.L98
 512:hardware/src/grey.c **** 			{
 1939              		.loc 1 512 62 discriminator 1
 1940 00fa 7B6C     		ldr	r3, [r7, #68]
 1941 00fc FA68     		ldr	r2, [r7, #12]
 1942 00fe 1344     		add	r3, r3, r2
 1943 0100 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 512:hardware/src/grey.c **** 			{
 1944              		.loc 1 512 46 discriminator 1
 1945 0102 002B     		cmp	r3, #0
 1946 0104 F3D0     		beq	.L92
 515:hardware/src/grey.c **** 			}
 516:hardware/src/grey.c **** 			continue;
 1947              		.loc 1 516 4
 1948 0106 64E0     		b	.L98
 1949              	.L85:
 1950              	.LBB9:
 517:hardware/src/grey.c **** 		}
 518:hardware/src/grey.c **** 		//连续三个位置的比较，实时存储
 519:hardware/src/grey.c **** 		if((needBlackLoc[i] != 0) && (needBlackLoc[i+1] != 0) && (needBlackLoc[i+2] != 0) &&
 1951              		.loc 1 519 19
 1952 0108 7B6C     		ldr	r3, [r7, #68]
 1953 010a FA68     		ldr	r2, [r7, #12]
 1954 010c 1344     		add	r3, r3, r2
 1955 010e 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
ARM GAS  /tmp/ccBaawNW.s 			page 45


 1956              		.loc 1 519 5
 1957 0110 002B     		cmp	r3, #0
 1958 0112 5FD0     		beq	.L93
 1959              		.loc 1 519 45 discriminator 1
 1960 0114 7B6C     		ldr	r3, [r7, #68]
 1961 0116 0133     		adds	r3, r3, #1
 1962 0118 FA68     		ldr	r2, [r7, #12]
 1963 011a 1344     		add	r3, r3, r2
 1964 011c 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 1965              		.loc 1 519 29 discriminator 1
 1966 011e 002B     		cmp	r3, #0
 1967 0120 58D0     		beq	.L93
 1968              		.loc 1 519 73 discriminator 2
 1969 0122 7B6C     		ldr	r3, [r7, #68]
 1970 0124 0233     		adds	r3, r3, #2
 1971 0126 FA68     		ldr	r2, [r7, #12]
 1972 0128 1344     		add	r3, r3, r2
 1973 012a 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 1974              		.loc 1 519 57 discriminator 2
 1975 012c 002B     		cmp	r3, #0
 1976 012e 51D0     		beq	.L93
 520:hardware/src/grey.c **** 			(abs((needBlackLoc[i] - needBlackLoc[i+1]) - (needBlackLoc[i+1] - needBlackLoc[i+2])) <= DEVIATI
 1977              		.loc 1 520 22 discriminator 3
 1978 0130 7B6C     		ldr	r3, [r7, #68]
 1979 0132 FA68     		ldr	r2, [r7, #12]
 1980 0134 1344     		add	r3, r3, r2
 1981 0136 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 1982 0138 1946     		mov	r1, r3
 1983              		.loc 1 520 40 discriminator 3
 1984 013a 7B6C     		ldr	r3, [r7, #68]
 1985 013c 0133     		adds	r3, r3, #1
 1986 013e FA68     		ldr	r2, [r7, #12]
 1987 0140 1344     		add	r3, r3, r2
 1988 0142 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 1989              		.loc 1 520 26 discriminator 3
 1990 0144 CA1A     		subs	r2, r1, r3
 1991              		.loc 1 520 62 discriminator 3
 1992 0146 7B6C     		ldr	r3, [r7, #68]
 1993 0148 0133     		adds	r3, r3, #1
 1994 014a F968     		ldr	r1, [r7, #12]
 1995 014c 0B44     		add	r3, r3, r1
 1996 014e 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 1997 0150 1846     		mov	r0, r3
 1998              		.loc 1 520 82 discriminator 3
 1999 0152 7B6C     		ldr	r3, [r7, #68]
 2000 0154 0233     		adds	r3, r3, #2
 2001 0156 F968     		ldr	r1, [r7, #12]
 2002 0158 0B44     		add	r3, r3, r1
 2003 015a 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 2004              		.loc 1 520 68 discriminator 3
 2005 015c C31A     		subs	r3, r0, r3
 2006              		.loc 1 520 47 discriminator 3
 2007 015e D31A     		subs	r3, r2, r3
 519:hardware/src/grey.c **** 			(abs((needBlackLoc[i] - needBlackLoc[i+1]) - (needBlackLoc[i+1] - needBlackLoc[i+2])) <= DEVIATI
 2008              		.loc 1 519 85 discriminator 3
 2009 0160 13F1030F 		cmn	r3, #3
 2010 0164 36DB     		blt	.L93
ARM GAS  /tmp/ccBaawNW.s 			page 46


 2011              		.loc 1 520 22
 2012 0166 7B6C     		ldr	r3, [r7, #68]
 2013 0168 FA68     		ldr	r2, [r7, #12]
 2014 016a 1344     		add	r3, r3, r2
 2015 016c 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 2016 016e 1946     		mov	r1, r3
 2017              		.loc 1 520 40
 2018 0170 7B6C     		ldr	r3, [r7, #68]
 2019 0172 0133     		adds	r3, r3, #1
 2020 0174 FA68     		ldr	r2, [r7, #12]
 2021 0176 1344     		add	r3, r3, r2
 2022 0178 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 2023              		.loc 1 520 26
 2024 017a CA1A     		subs	r2, r1, r3
 2025              		.loc 1 520 62
 2026 017c 7B6C     		ldr	r3, [r7, #68]
 2027 017e 0133     		adds	r3, r3, #1
 2028 0180 F968     		ldr	r1, [r7, #12]
 2029 0182 0B44     		add	r3, r3, r1
 2030 0184 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 2031 0186 1846     		mov	r0, r3
 2032              		.loc 1 520 82
 2033 0188 7B6C     		ldr	r3, [r7, #68]
 2034 018a 0233     		adds	r3, r3, #2
 2035 018c F968     		ldr	r1, [r7, #12]
 2036 018e 0B44     		add	r3, r3, r1
 2037 0190 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 2038              		.loc 1 520 68
 2039 0192 C31A     		subs	r3, r0, r3
 2040              		.loc 1 520 47
 2041 0194 D31A     		subs	r3, r2, r3
 2042              		.loc 1 520 90
 2043 0196 032B     		cmp	r3, #3
 2044 0198 1CDC     		bgt	.L93
 521:hardware/src/grey.c **** 		{
 522:hardware/src/grey.c **** 			/*存储进临时数组中*/
 523:hardware/src/grey.c **** 			tmpMaxUsefulLine[tmpMaxUsefulLineLen] = needBlackLoc[i];
 2045              		.loc 1 523 56
 2046 019a 7B6C     		ldr	r3, [r7, #68]
 2047 019c FA68     		ldr	r2, [r7, #12]
 2048 019e 1A44     		add	r2, r2, r3
 2049              		.loc 1 523 20
 2050 01a0 97F83F30 		ldrb	r3, [r7, #63]	@ zero_extendqisi2
 2051              		.loc 1 523 56
 2052 01a4 1278     		ldrb	r2, [r2]	@ zero_extendqisi2
 2053              		.loc 1 523 42
 2054 01a6 07F14801 		add	r1, r7, #72
 2055 01aa 0B44     		add	r3, r3, r1
 2056 01ac 03F8202C 		strb	r2, [r3, #-32]
 524:hardware/src/grey.c **** 			// tmpmaxUBlackHeight[tmpMaxUsefulLineLen] = i;//存储高度
 525:hardware/src/grey.c **** 			tmpmaxUBlackHeight[tmpMaxUsefulLineLen] = i*SKIPLINE;//存储高度
 2057              		.loc 1 525 44
 2058 01b0 7B6C     		ldr	r3, [r7, #68]
 2059 01b2 DAB2     		uxtb	r2, r3
 2060              		.loc 1 525 22
 2061 01b4 97F83F30 		ldrb	r3, [r7, #63]	@ zero_extendqisi2
 2062              		.loc 1 525 44
ARM GAS  /tmp/ccBaawNW.s 			page 47


 2063 01b8 9200     		lsls	r2, r2, #2
 2064 01ba D2B2     		uxtb	r2, r2
 2065 01bc 07F14801 		add	r1, r7, #72
 2066 01c0 0B44     		add	r3, r3, r1
 2067 01c2 03F8342C 		strb	r2, [r3, #-52]
 526:hardware/src/grey.c **** 			tmpMaxUsefulLineLen ++;
 2068              		.loc 1 526 24
 2069 01c6 97F83F30 		ldrb	r3, [r7, #63]	@ zero_extendqisi2
 2070 01ca 0133     		adds	r3, r3, #1
 2071 01cc 87F83F30 		strb	r3, [r7, #63]
 2072 01d0 00E0     		b	.L93
 2073              	.L98:
 2074              	.LBE9:
 516:hardware/src/grey.c **** 		}
 2075              		.loc 1 516 4
 2076 01d2 00BF     		nop
 2077              	.L93:
 480:hardware/src/grey.c **** 	{
 2078              		.loc 1 480 54 discriminator 2
 2079 01d4 7B6C     		ldr	r3, [r7, #68]
 2080 01d6 0133     		adds	r3, r3, #1
 2081 01d8 7B64     		str	r3, [r7, #68]
 2082              	.L84:
 480:hardware/src/grey.c **** 	{
 2083              		.loc 1 480 2 discriminator 1
 2084 01da 7B6C     		ldr	r3, [r7, #68]
 2085 01dc 112B     		cmp	r3, #17
 2086 01de 7FF736AF 		ble	.L94
 527:hardware/src/grey.c **** 		}
 528:hardware/src/grey.c **** 	}
 529:hardware/src/grey.c **** 	
 530:hardware/src/grey.c **** 	/*从有效位置开始，全部有符合的位置，做存储和清空操作*/
 531:hardware/src/grey.c **** 	//如果段比较长的话，才选中
 532:hardware/src/grey.c **** 	if((*maxUBlackLineLen) < tmpMaxUsefulLineLen)
 2087              		.loc 1 532 6
 2088 01e2 3B68     		ldr	r3, [r7]
 2089 01e4 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 2090              		.loc 1 532 4
 2091 01e6 97F83F20 		ldrb	r2, [r7, #63]	@ zero_extendqisi2
 2092 01ea 9A42     		cmp	r2, r3
 2093 01ec 2AD9     		bls	.L95
 533:hardware/src/grey.c **** 	{
 534:hardware/src/grey.c **** 		//存储
 535:hardware/src/grey.c **** 		(*maxUBlackLineLen) = tmpMaxUsefulLineLen;
 2094              		.loc 1 535 23
 2095 01ee 3B68     		ldr	r3, [r7]
 2096 01f0 97F83F20 		ldrb	r2, [r7, #63]
 2097 01f4 1A70     		strb	r2, [r3]
 536:hardware/src/grey.c **** 		memset(maxUBlackHeight,0,(NEEDHEIGHT)/(SKIPLINE));//清空高度，以备存储
 2098              		.loc 1 536 3
 2099 01f6 1422     		movs	r2, #20
 2100 01f8 0021     		movs	r1, #0
 2101 01fa 386D     		ldr	r0, [r7, #80]
 2102 01fc FFF7FEFF 		bl	memset
 537:hardware/src/grey.c **** 		memset(maxUBlackLine,0,(NEEDHEIGHT)/(SKIPLINE));//清空以备存储
 2103              		.loc 1 537 3
 2104 0200 1422     		movs	r2, #20
ARM GAS  /tmp/ccBaawNW.s 			page 48


 2105 0202 0021     		movs	r1, #0
 2106 0204 7868     		ldr	r0, [r7, #4]
 2107 0206 FFF7FEFF 		bl	memset
 538:hardware/src/grey.c **** 		for(j = 0;j <= tmpMaxUsefulLineLen;j ++)
 2108              		.loc 1 538 9
 2109 020a 0023     		movs	r3, #0
 2110 020c 3B64     		str	r3, [r7, #64]
 2111              		.loc 1 538 3
 2112 020e 14E0     		b	.L96
 2113              	.L97:
 539:hardware/src/grey.c **** 		{
 540:hardware/src/grey.c **** 			maxUBlackLine[j] = tmpMaxUsefulLine[j];
 2114              		.loc 1 540 17 discriminator 3
 2115 0210 3B6C     		ldr	r3, [r7, #64]
 2116 0212 7A68     		ldr	r2, [r7, #4]
 2117 0214 1344     		add	r3, r3, r2
 2118              		.loc 1 540 39 discriminator 3
 2119 0216 07F12801 		add	r1, r7, #40
 2120 021a 3A6C     		ldr	r2, [r7, #64]
 2121 021c 0A44     		add	r2, r2, r1
 2122 021e 1278     		ldrb	r2, [r2]	@ zero_extendqisi2
 2123              		.loc 1 540 21 discriminator 3
 2124 0220 1A70     		strb	r2, [r3]
 541:hardware/src/grey.c **** 			maxUBlackHeight[j] = tmpmaxUBlackHeight[j];//存储高度
 2125              		.loc 1 541 19 discriminator 3
 2126 0222 3B6C     		ldr	r3, [r7, #64]
 2127 0224 3A6D     		ldr	r2, [r7, #80]
 2128 0226 1344     		add	r3, r3, r2
 2129              		.loc 1 541 43 discriminator 3
 2130 0228 07F11401 		add	r1, r7, #20
 2131 022c 3A6C     		ldr	r2, [r7, #64]
 2132 022e 0A44     		add	r2, r2, r1
 2133 0230 1278     		ldrb	r2, [r2]	@ zero_extendqisi2
 2134              		.loc 1 541 23 discriminator 3
 2135 0232 1A70     		strb	r2, [r3]
 538:hardware/src/grey.c **** 		for(j = 0;j <= tmpMaxUsefulLineLen;j ++)
 2136              		.loc 1 538 40 discriminator 3
 2137 0234 3B6C     		ldr	r3, [r7, #64]
 2138 0236 0133     		adds	r3, r3, #1
 2139 0238 3B64     		str	r3, [r7, #64]
 2140              	.L96:
 538:hardware/src/grey.c **** 		for(j = 0;j <= tmpMaxUsefulLineLen;j ++)
 2141              		.loc 1 538 15 discriminator 1
 2142 023a 97F83F30 		ldrb	r3, [r7, #63]	@ zero_extendqisi2
 538:hardware/src/grey.c **** 		for(j = 0;j <= tmpMaxUsefulLineLen;j ++)
 2143              		.loc 1 538 3 discriminator 1
 2144 023e 3A6C     		ldr	r2, [r7, #64]
 2145 0240 9A42     		cmp	r2, r3
 2146 0242 E5DD     		ble	.L97
 2147              	.L95:
 542:hardware/src/grey.c **** 		}
 543:hardware/src/grey.c **** 	}
 544:hardware/src/grey.c **** 	//存完清空
 545:hardware/src/grey.c **** 	memset(tmpMaxUsefulLine,0,(NEEDHEIGHT)/(SKIPLINE));
 2148              		.loc 1 545 2
 2149 0244 07F12803 		add	r3, r7, #40
 2150 0248 1422     		movs	r2, #20
ARM GAS  /tmp/ccBaawNW.s 			page 49


 2151 024a 0021     		movs	r1, #0
 2152 024c 1846     		mov	r0, r3
 2153 024e FFF7FEFF 		bl	memset
 546:hardware/src/grey.c **** 	memset(tmpmaxUBlackHeight,0,(NEEDHEIGHT)/(SKIPLINE));
 2154              		.loc 1 546 2
 2155 0252 07F11403 		add	r3, r7, #20
 2156 0256 1422     		movs	r2, #20
 2157 0258 0021     		movs	r1, #0
 2158 025a 1846     		mov	r0, r3
 2159 025c FFF7FEFF 		bl	memset
 547:hardware/src/grey.c **** 	tmpMaxUsefulLineLen = 0;
 2160              		.loc 1 547 22
 2161 0260 0023     		movs	r3, #0
 2162 0262 87F83F30 		strb	r3, [r7, #63]
 548:hardware/src/grey.c **** }
 2163              		.loc 1 548 1
 2164 0266 00BF     		nop
 2165 0268 4837     		adds	r7, r7, #72
 2166              	.LCFI33:
 2167              		.cfi_def_cfa_offset 8
 2168 026a BD46     		mov	sp, r7
 2169              	.LCFI34:
 2170              		.cfi_def_cfa_register 13
 2171              		@ sp needed
 2172 026c 80BD     		pop	{r7, pc}
 2173              		.cfi_endproc
 2174              	.LFE70:
 2176              		.section	.text.getUsefulLine,"ax",%progbits
 2177              		.align	1
 2178              		.global	getUsefulLine
 2179              		.syntax unified
 2180              		.thumb
 2181              		.thumb_func
 2182              		.fpu softvfp
 2184              	getUsefulLine:
 2185              	.LFB71:
 549:hardware/src/grey.c **** 
 550:hardware/src/grey.c **** // /*函数功能：从边界数组中，提取出有效的连续段，取出最为有效可靠的段。*/
 551:hardware/src/grey.c **** int getUsefulLine()
 552:hardware/src/grey.c **** {	  
 2186              		.loc 1 552 1
 2187              		.cfi_startproc
 2188              		@ args = 0, pretend = 0, frame = 8
 2189              		@ frame_needed = 1, uses_anonymous_args = 0
 2190 0000 80B5     		push	{r7, lr}
 2191              	.LCFI35:
 2192              		.cfi_def_cfa_offset 8
 2193              		.cfi_offset 7, -8
 2194              		.cfi_offset 14, -4
 2195 0002 84B0     		sub	sp, sp, #16
 2196              	.LCFI36:
 2197              		.cfi_def_cfa_offset 24
 2198 0004 02AF     		add	r7, sp, #8
 2199              	.LCFI37:
 2200              		.cfi_def_cfa 7, 16
 553:hardware/src/grey.c **** 	//默认边界没有找到
 554:hardware/src/grey.c **** 	u8 LeftDirect = LEFTLOST;
ARM GAS  /tmp/ccBaawNW.s 			page 50


 2201              		.loc 1 554 5
 2202 0006 0723     		movs	r3, #7
 2203 0008 FB71     		strb	r3, [r7, #7]
 555:hardware/src/grey.c **** 	u8 RightDirect = RIGHTLOST;
 2204              		.loc 1 555 5
 2205 000a 0823     		movs	r3, #8
 2206 000c BB71     		strb	r3, [r7, #6]
 556:hardware/src/grey.c **** 	/*临时变量*/
 557:hardware/src/grey.c **** 	u8 countLeftZero = 0;//统计一个边界中的0的无用数据个数的临时变量
 2207              		.loc 1 557 5
 2208 000e 0023     		movs	r3, #0
 2209 0010 7B71     		strb	r3, [r7, #5]
 558:hardware/src/grey.c **** 	u8 countRightZero = 0;//统计一个边界中的0的无用数据个数的临时变量
 2210              		.loc 1 558 5
 2211 0012 0023     		movs	r3, #0
 2212 0014 3B71     		strb	r3, [r7, #4]
 559:hardware/src/grey.c **** 	u8 i;
 560:hardware/src/grey.c **** 
 561:hardware/src/grey.c **** /*预先对左右边界进行处理，如果没有检测到就必须返回，结束此函数*/
 562:hardware/src/grey.c **** 	/*左边滤除数组开始的0操作*/
 563:hardware/src/grey.c **** 	while((countLeftZero < 20) && (leftBlackLoc[countLeftZero] == 0))
 2213              		.loc 1 563 7
 2214 0016 02E0     		b	.L100
 2215              	.L102:
 564:hardware/src/grey.c **** 	{
 565:hardware/src/grey.c **** 		countLeftZero ++;//下一个数据
 2216              		.loc 1 565 17
 2217 0018 7B79     		ldrb	r3, [r7, #5]	@ zero_extendqisi2
 2218 001a 0133     		adds	r3, r3, #1
 2219 001c 7B71     		strb	r3, [r7, #5]
 2220              	.L100:
 563:hardware/src/grey.c **** 	{
 2221              		.loc 1 563 7
 2222 001e 7B79     		ldrb	r3, [r7, #5]	@ zero_extendqisi2
 2223 0020 132B     		cmp	r3, #19
 2224 0022 04D8     		bhi	.L101
 563:hardware/src/grey.c **** 	{
 2225              		.loc 1 563 45 discriminator 1
 2226 0024 7B79     		ldrb	r3, [r7, #5]	@ zero_extendqisi2
 2227 0026 444A     		ldr	r2, .L120
 2228 0028 D35C     		ldrb	r3, [r2, r3]	@ zero_extendqisi2
 563:hardware/src/grey.c **** 	{
 2229              		.loc 1 563 29 discriminator 1
 2230 002a 002B     		cmp	r3, #0
 2231 002c F4D0     		beq	.L102
 2232              	.L101:
 566:hardware/src/grey.c **** 	}
 567:hardware/src/grey.c **** 	if(countLeftZero == 20)//如果全部为0，那么就是没有边界，直接将标志位置为lost丢失
 2233              		.loc 1 567 4
 2234 002e 7B79     		ldrb	r3, [r7, #5]	@ zero_extendqisi2
 2235 0030 142B     		cmp	r3, #20
 2236 0032 02D1     		bne	.L103
 568:hardware/src/grey.c **** 	{
 569:hardware/src/grey.c **** 		LeftDirect = LEFTLOST;
 2237              		.loc 1 569 14
 2238 0034 0723     		movs	r3, #7
 2239 0036 FB71     		strb	r3, [r7, #7]
ARM GAS  /tmp/ccBaawNW.s 			page 51


 2240 0038 05E0     		b	.L105
 2241              	.L103:
 570:hardware/src/grey.c **** 	}
 571:hardware/src/grey.c **** 	else
 572:hardware/src/grey.c **** 	{
 573:hardware/src/grey.c **** 		LeftDirect = GETDIRECT;
 2242              		.loc 1 573 14
 2243 003a 0923     		movs	r3, #9
 2244 003c FB71     		strb	r3, [r7, #7]
 574:hardware/src/grey.c **** 	}
 575:hardware/src/grey.c **** 	
 576:hardware/src/grey.c **** 	/*右边滤除0操作*/
 577:hardware/src/grey.c **** 	while((countRightZero < 20) && (rightBlackLoc[countRightZero] == 0))
 2245              		.loc 1 577 7
 2246 003e 02E0     		b	.L105
 2247              	.L107:
 578:hardware/src/grey.c **** 	{
 579:hardware/src/grey.c **** 		//下一个数据
 580:hardware/src/grey.c **** 		countRightZero ++;
 2248              		.loc 1 580 18
 2249 0040 3B79     		ldrb	r3, [r7, #4]	@ zero_extendqisi2
 2250 0042 0133     		adds	r3, r3, #1
 2251 0044 3B71     		strb	r3, [r7, #4]
 2252              	.L105:
 577:hardware/src/grey.c **** 	{
 2253              		.loc 1 577 7
 2254 0046 3B79     		ldrb	r3, [r7, #4]	@ zero_extendqisi2
 2255 0048 132B     		cmp	r3, #19
 2256 004a 04D8     		bhi	.L106
 577:hardware/src/grey.c **** 	{
 2257              		.loc 1 577 47 discriminator 1
 2258 004c 3B79     		ldrb	r3, [r7, #4]	@ zero_extendqisi2
 2259 004e 3B4A     		ldr	r2, .L120+4
 2260 0050 D35C     		ldrb	r3, [r2, r3]	@ zero_extendqisi2
 577:hardware/src/grey.c **** 	{
 2261              		.loc 1 577 30 discriminator 1
 2262 0052 002B     		cmp	r3, #0
 2263 0054 F4D0     		beq	.L107
 2264              	.L106:
 581:hardware/src/grey.c **** 	}
 582:hardware/src/grey.c **** 	if(countRightZero == 20)//如果全部为0，那么就是没有边界，直接将标志位置为lost丢失
 2265              		.loc 1 582 4
 2266 0056 3B79     		ldrb	r3, [r7, #4]	@ zero_extendqisi2
 2267 0058 142B     		cmp	r3, #20
 2268 005a 02D1     		bne	.L108
 583:hardware/src/grey.c **** 	{
 584:hardware/src/grey.c **** 		RightDirect = RIGHTLOST;
 2269              		.loc 1 584 15
 2270 005c 0823     		movs	r3, #8
 2271 005e BB71     		strb	r3, [r7, #6]
 2272 0060 01E0     		b	.L109
 2273              	.L108:
 585:hardware/src/grey.c **** 	}
 586:hardware/src/grey.c **** 	else
 587:hardware/src/grey.c **** 	{
 588:hardware/src/grey.c **** 		RightDirect = GETDIRECT;
 2274              		.loc 1 588 15
ARM GAS  /tmp/ccBaawNW.s 			page 52


 2275 0062 0923     		movs	r3, #9
 2276 0064 BB71     		strb	r3, [r7, #6]
 2277              	.L109:
 589:hardware/src/grey.c **** 	}
 590:hardware/src/grey.c **** 	//均丢失，那么就直接结束函数
 591:hardware/src/grey.c **** 	if((LeftDirect == LEFTLOST) && (RightDirect == RIGHTLOST))
 2278              		.loc 1 591 4
 2279 0066 FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 2280 0068 072B     		cmp	r3, #7
 2281 006a 04D1     		bne	.L110
 2282              		.loc 1 591 30 discriminator 1
 2283 006c BB79     		ldrb	r3, [r7, #6]	@ zero_extendqisi2
 2284 006e 082B     		cmp	r3, #8
 2285 0070 01D1     		bne	.L110
 592:hardware/src/grey.c **** 	{
 593:hardware/src/grey.c **** 		return BOTHLOST;
 2286              		.loc 1 593 10
 2287 0072 0A23     		movs	r3, #10
 2288 0074 5CE0     		b	.L111
 2289              	.L110:
 594:hardware/src/grey.c **** 	}
 595:hardware/src/grey.c **** 	
 596:hardware/src/grey.c **** 	if(LeftDirect==GETDIRECT && RightDirect==GETDIRECT && FLAG_BORDER!=0){
 2290              		.loc 1 596 4
 2291 0076 FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 2292 0078 092B     		cmp	r3, #9
 2293 007a 20D1     		bne	.L112
 2294              		.loc 1 596 27 discriminator 1
 2295 007c BB79     		ldrb	r3, [r7, #6]	@ zero_extendqisi2
 2296 007e 092B     		cmp	r3, #9
 2297 0080 1DD1     		bne	.L112
 2298              		.loc 1 596 67 discriminator 2
 2299 0082 2F4B     		ldr	r3, .L120+8
 2300 0084 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 2301              		.loc 1 596 53 discriminator 2
 2302 0086 002B     		cmp	r3, #0
 2303 0088 19D0     		beq	.L112
 597:hardware/src/grey.c **** 		if(FLAG_BORDER == 1){
 2304              		.loc 1 597 18
 2305 008a 2D4B     		ldr	r3, .L120+8
 2306 008c 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 2307              		.loc 1 597 5
 2308 008e 012B     		cmp	r3, #1
 2309 0090 08D1     		bne	.L113
 598:hardware/src/grey.c **** 			getOneSideUsefulLine(rightBlackLoc,countRightZero,maxUsefulBlackLine,&maxUsefulLineLen,maxUseful
 2310              		.loc 1 598 4
 2311 0092 3979     		ldrb	r1, [r7, #4]	@ zero_extendqisi2
 2312 0094 2B4B     		ldr	r3, .L120+12
 2313 0096 0093     		str	r3, [sp]
 2314 0098 2B4B     		ldr	r3, .L120+16
 2315 009a 2C4A     		ldr	r2, .L120+20
 2316 009c 2748     		ldr	r0, .L120+4
 2317 009e FFF7FEFF 		bl	getOneSideUsefulLine
 597:hardware/src/grey.c **** 		if(FLAG_BORDER == 1){
 2318              		.loc 1 597 5
 2319 00a2 24E0     		b	.L119
 2320              	.L113:
ARM GAS  /tmp/ccBaawNW.s 			page 53


 599:hardware/src/grey.c **** 		}
 600:hardware/src/grey.c **** 		else if(FLAG_BORDER == 2){
 2321              		.loc 1 600 23
 2322 00a4 264B     		ldr	r3, .L120+8
 2323 00a6 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 2324              		.loc 1 600 10
 2325 00a8 022B     		cmp	r3, #2
 2326 00aa 20D1     		bne	.L119
 601:hardware/src/grey.c **** 			getOneSideUsefulLine(leftBlackLoc,countLeftZero,maxUsefulBlackLine,&maxUsefulLineLen,maxUsefulBl
 2327              		.loc 1 601 4
 2328 00ac 7979     		ldrb	r1, [r7, #5]	@ zero_extendqisi2
 2329 00ae 254B     		ldr	r3, .L120+12
 2330 00b0 0093     		str	r3, [sp]
 2331 00b2 254B     		ldr	r3, .L120+16
 2332 00b4 254A     		ldr	r2, .L120+20
 2333 00b6 2048     		ldr	r0, .L120
 2334 00b8 FFF7FEFF 		bl	getOneSideUsefulLine
 597:hardware/src/grey.c **** 			getOneSideUsefulLine(rightBlackLoc,countRightZero,maxUsefulBlackLine,&maxUsefulLineLen,maxUseful
 2335              		.loc 1 597 5
 2336 00bc 17E0     		b	.L119
 2337              	.L112:
 602:hardware/src/grey.c **** 		}
 603:hardware/src/grey.c **** 	}
 604:hardware/src/grey.c **** 	else{
 605:hardware/src/grey.c **** 		/*左右边界检测开始*/
 606:hardware/src/grey.c **** 		/*如果左边边界检测到了，那么才检测这个数组*/
 607:hardware/src/grey.c **** 		if(LeftDirect == GETDIRECT)
 2338              		.loc 1 607 5
 2339 00be FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 2340 00c0 092B     		cmp	r3, #9
 2341 00c2 08D1     		bne	.L116
 608:hardware/src/grey.c **** 		{
 609:hardware/src/grey.c **** 			getOneSideUsefulLine(leftBlackLoc,countLeftZero,maxUsefulBlackLine,&maxUsefulLineLen,maxUsefulBl
 2342              		.loc 1 609 4
 2343 00c4 7979     		ldrb	r1, [r7, #5]	@ zero_extendqisi2
 2344 00c6 1F4B     		ldr	r3, .L120+12
 2345 00c8 0093     		str	r3, [sp]
 2346 00ca 1F4B     		ldr	r3, .L120+16
 2347 00cc 1F4A     		ldr	r2, .L120+20
 2348 00ce 1A48     		ldr	r0, .L120
 2349 00d0 FFF7FEFF 		bl	getOneSideUsefulLine
 2350 00d4 0CE0     		b	.L115
 2351              	.L116:
 610:hardware/src/grey.c **** #if defined(DEBUG_CAMERA) && DEBUG_CAMERA
 611:hardware/src/grey.c **** 			printf("get left line,maxusefullen:%d\r\n",maxUsefulLineLen);
 612:hardware/src/grey.c **** 			for(i=0;i<(NEEDHEIGHT)/(SKIPLINE);i++){
 613:hardware/src/grey.c **** 				printf("%d ",leftBlackLoc[i]);
 614:hardware/src/grey.c **** 			}
 615:hardware/src/grey.c **** 			printf("\r\n");
 616:hardware/src/grey.c **** #endif
 617:hardware/src/grey.c **** 		}
 618:hardware/src/grey.c **** 		/*如果右边边界检测到了，那么才开始检测数组*/
 619:hardware/src/grey.c **** 		else if(RightDirect == GETDIRECT)
 2352              		.loc 1 619 10
 2353 00d6 BB79     		ldrb	r3, [r7, #6]	@ zero_extendqisi2
 2354 00d8 092B     		cmp	r3, #9
 2355 00da 09D1     		bne	.L115
ARM GAS  /tmp/ccBaawNW.s 			page 54


 620:hardware/src/grey.c **** 		{
 621:hardware/src/grey.c **** 			getOneSideUsefulLine(rightBlackLoc,countRightZero,maxUsefulBlackLine,&maxUsefulLineLen,maxUseful
 2356              		.loc 1 621 4
 2357 00dc 3979     		ldrb	r1, [r7, #4]	@ zero_extendqisi2
 2358 00de 194B     		ldr	r3, .L120+12
 2359 00e0 0093     		str	r3, [sp]
 2360 00e2 194B     		ldr	r3, .L120+16
 2361 00e4 194A     		ldr	r2, .L120+20
 2362 00e6 1548     		ldr	r0, .L120+4
 2363 00e8 FFF7FEFF 		bl	getOneSideUsefulLine
 2364 00ec 00E0     		b	.L115
 2365              	.L119:
 597:hardware/src/grey.c **** 			getOneSideUsefulLine(rightBlackLoc,countRightZero,maxUsefulBlackLine,&maxUsefulLineLen,maxUseful
 2366              		.loc 1 597 5
 2367 00ee 00BF     		nop
 2368              	.L115:
 622:hardware/src/grey.c **** 		}
 623:hardware/src/grey.c **** 	}
 624:hardware/src/grey.c **** 	
 625:hardware/src/grey.c **** 	/*要是只有一个或者根本就没有获取到最长段数据，那么这次的采集就是失败的，返回失败的信号*/
 626:hardware/src/grey.c **** 	if((maxUsefulLineLen == 0) || (maxUsefulLineLen == 1) || (maxUsefulLineLen == 2) || (maxUsefulLine
 2369              		.loc 1 626 23
 2370 00f0 154B     		ldr	r3, .L120+16
 2371 00f2 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 2372              		.loc 1 626 4
 2373 00f4 002B     		cmp	r3, #0
 2374 00f6 0BD0     		beq	.L117
 2375              		.loc 1 626 50 discriminator 1
 2376 00f8 134B     		ldr	r3, .L120+16
 2377 00fa 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 2378              		.loc 1 626 29 discriminator 1
 2379 00fc 012B     		cmp	r3, #1
 2380 00fe 07D0     		beq	.L117
 2381              		.loc 1 626 77 discriminator 2
 2382 0100 114B     		ldr	r3, .L120+16
 2383 0102 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 2384              		.loc 1 626 56 discriminator 2
 2385 0104 022B     		cmp	r3, #2
 2386 0106 03D0     		beq	.L117
 2387              		.loc 1 626 104 discriminator 3
 2388 0108 0F4B     		ldr	r3, .L120+16
 2389 010a 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 2390              		.loc 1 626 83 discriminator 3
 2391 010c 032B     		cmp	r3, #3
 2392 010e 0ED1     		bne	.L118
 2393              	.L117:
 627:hardware/src/grey.c **** 	{
 628:hardware/src/grey.c **** 			/*清空返回*/
 629:hardware/src/grey.c **** 		maxUsefulLineLen = 0;
 2394              		.loc 1 629 20
 2395 0110 0D4B     		ldr	r3, .L120+16
 2396 0112 0022     		movs	r2, #0
 2397 0114 1A70     		strb	r2, [r3]
 630:hardware/src/grey.c **** 		memset(maxUsefulBlackHeight,0,(NEEDHEIGHT)/(SKIPLINE));
 2398              		.loc 1 630 3
 2399 0116 1422     		movs	r2, #20
 2400 0118 0021     		movs	r1, #0
ARM GAS  /tmp/ccBaawNW.s 			page 55


 2401 011a 0A48     		ldr	r0, .L120+12
 2402 011c FFF7FEFF 		bl	memset
 631:hardware/src/grey.c **** 		memset(maxUsefulBlackLine,0,(NEEDHEIGHT)/(SKIPLINE));			
 2403              		.loc 1 631 3
 2404 0120 1422     		movs	r2, #20
 2405 0122 0021     		movs	r1, #0
 2406 0124 0948     		ldr	r0, .L120+20
 2407 0126 FFF7FEFF 		bl	memset
 632:hardware/src/grey.c **** 		return BOTHLOST;
 2408              		.loc 1 632 10
 2409 012a 0A23     		movs	r3, #10
 2410 012c 00E0     		b	.L111
 2411              	.L118:
 633:hardware/src/grey.c **** 	}
 634:hardware/src/grey.c **** 	return GETDIRECT;
 2412              		.loc 1 634 9
 2413 012e 0923     		movs	r3, #9
 2414              	.L111:
 635:hardware/src/grey.c **** }
 2415              		.loc 1 635 1
 2416 0130 1846     		mov	r0, r3
 2417 0132 0837     		adds	r7, r7, #8
 2418              	.LCFI38:
 2419              		.cfi_def_cfa_offset 8
 2420 0134 BD46     		mov	sp, r7
 2421              	.LCFI39:
 2422              		.cfi_def_cfa_register 13
 2423              		@ sp needed
 2424 0136 80BD     		pop	{r7, pc}
 2425              	.L121:
 2426              		.align	2
 2427              	.L120:
 2428 0138 00000000 		.word	leftBlackLoc
 2429 013c 00000000 		.word	rightBlackLoc
 2430 0140 00000000 		.word	FLAG_BORDER
 2431 0144 00000000 		.word	maxUsefulBlackHeight
 2432 0148 00000000 		.word	maxUsefulLineLen
 2433 014c 00000000 		.word	maxUsefulBlackLine
 2434              		.cfi_endproc
 2435              	.LFE71:
 2437              		.global	testLineWidth
 2438              		.section	.bss.testLineWidth,"aw",%nobits
 2441              	testLineWidth:
 2442 0000 00       		.space	1
 2443              		.section	.text.getLineWidth,"ax",%progbits
 2444              		.align	1
 2445              		.global	getLineWidth
 2446              		.syntax unified
 2447              		.thumb
 2448              		.thumb_func
 2449              		.fpu softvfp
 2451              	getLineWidth:
 2452              	.LFB72:
 636:hardware/src/grey.c **** 
 637:hardware/src/grey.c **** u8 testLineWidth = 0;
 638:hardware/src/grey.c **** 
 639:hardware/src/grey.c **** /*获得当前线宽*/
ARM GAS  /tmp/ccBaawNW.s 			page 56


 640:hardware/src/grey.c **** int getLineWidth(u8 *lMaxULine,u8 *rMaxULine,u8 lMaxULen,u8 rMaxULen,u8 *lMaxLineHei,u8 *rMaxLineHe
 641:hardware/src/grey.c **** {
 2453              		.loc 1 641 1
 2454              		.cfi_startproc
 2455              		@ args = 12, pretend = 0, frame = 24
 2456              		@ frame_needed = 1, uses_anonymous_args = 0
 2457              		@ link register save eliminated.
 2458 0000 80B4     		push	{r7}
 2459              	.LCFI40:
 2460              		.cfi_def_cfa_offset 4
 2461              		.cfi_offset 7, -4
 2462 0002 87B0     		sub	sp, sp, #28
 2463              	.LCFI41:
 2464              		.cfi_def_cfa_offset 32
 2465 0004 00AF     		add	r7, sp, #0
 2466              	.LCFI42:
 2467              		.cfi_def_cfa_register 7
 2468 0006 F860     		str	r0, [r7, #12]
 2469 0008 B960     		str	r1, [r7, #8]
 2470 000a 1146     		mov	r1, r2
 2471 000c 1A46     		mov	r2, r3
 2472 000e 0B46     		mov	r3, r1
 2473 0010 FB71     		strb	r3, [r7, #7]
 2474 0012 1346     		mov	r3, r2
 2475 0014 BB71     		strb	r3, [r7, #6]
 642:hardware/src/grey.c **** 	u8 i;
 643:hardware/src/grey.c **** 	// u8 j;
 644:hardware/src/grey.c **** 	// u8 m,n;
 645:hardware/src/grey.c **** 	//检测一个水平位置上，两个有效段均存在这个水平位置上有位置
 646:hardware/src/grey.c **** /*首先获得斜线的水平线宽*/
 647:hardware/src/grey.c **** 	if(lMaxULen <= rMaxULen)//左边最长有效线段较短，依据左边
 2476              		.loc 1 647 4
 2477 0016 FA79     		ldrb	r2, [r7, #7]	@ zero_extendqisi2
 2478 0018 BB79     		ldrb	r3, [r7, #6]	@ zero_extendqisi2
 2479 001a 9A42     		cmp	r2, r3
 2480 001c 30D8     		bhi	.L123
 648:hardware/src/grey.c **** 	{
 649:hardware/src/grey.c **** 		for(i = 0;i < lMaxULen;i ++)//开始匹配同一水平位置左右均存在有效交点
 2481              		.loc 1 649 9
 2482 001e 0023     		movs	r3, #0
 2483 0020 FB75     		strb	r3, [r7, #23]
 2484              		.loc 1 649 3
 2485 0022 28E0     		b	.L124
 2486              	.L127:
 650:hardware/src/grey.c **** 		{
 651:hardware/src/grey.c **** 			// if(rightBlackLoc[lMaxLineHei[i]] != 0)//在左边有效位置高度，存在右边有效线段交点
 652:hardware/src/grey.c **** 			if(rightBlackLoc[lMaxLineHei[i]/SKIPLINE] != 0)//在左边有效位置高度，存在右边有效线段交点
 2487              		.loc 1 652 32
 2488 0024 FB7D     		ldrb	r3, [r7, #23]	@ zero_extendqisi2
 2489 0026 3A6A     		ldr	r2, [r7, #32]
 2490 0028 1344     		add	r3, r3, r2
 2491 002a 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 2492              		.loc 1 652 35
 2493 002c 9B08     		lsrs	r3, r3, #2
 2494 002e DBB2     		uxtb	r3, r3
 2495 0030 1A46     		mov	r2, r3
 2496              		.loc 1 652 20
ARM GAS  /tmp/ccBaawNW.s 			page 57


 2497 0032 364B     		ldr	r3, .L132
 2498 0034 9B5C     		ldrb	r3, [r3, r2]	@ zero_extendqisi2
 2499              		.loc 1 652 6
 2500 0036 002B     		cmp	r3, #0
 2501 0038 1AD0     		beq	.L125
 2502              	.LBB10:
 653:hardware/src/grey.c **** 			{
 654:hardware/src/grey.c **** 				// *lineWidth = abs(rightBlackLoc[lMaxLineHei[i]] - lMaxULine[i]);
 655:hardware/src/grey.c **** 				*lineWidth = abs(rightBlackLoc[lMaxLineHei[i]/SKIPLINE] - lMaxULine[i]);
 2503              		.loc 1 655 47
 2504 003a FB7D     		ldrb	r3, [r7, #23]	@ zero_extendqisi2
 2505 003c 3A6A     		ldr	r2, [r7, #32]
 2506 003e 1344     		add	r3, r3, r2
 2507 0040 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 2508              		.loc 1 655 50
 2509 0042 9B08     		lsrs	r3, r3, #2
 2510 0044 DBB2     		uxtb	r3, r3
 2511 0046 1A46     		mov	r2, r3
 2512              		.loc 1 655 35
 2513 0048 304B     		ldr	r3, .L132
 2514 004a 9B5C     		ldrb	r3, [r3, r2]	@ zero_extendqisi2
 2515 004c 1946     		mov	r1, r3
 2516              		.loc 1 655 72
 2517 004e FB7D     		ldrb	r3, [r7, #23]	@ zero_extendqisi2
 2518 0050 FA68     		ldr	r2, [r7, #12]
 2519 0052 1344     		add	r3, r3, r2
 2520 0054 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 2521              		.loc 1 655 61
 2522 0056 CB1A     		subs	r3, r1, r3
 2523              		.loc 1 655 18
 2524 0058 002B     		cmp	r3, #0
 2525 005a B8BF     		it	lt
 2526 005c 5B42     		rsblt	r3, r3, #0
 2527              		.loc 1 655 16
 2528 005e DAB2     		uxtb	r2, r3
 2529 0060 BB6A     		ldr	r3, [r7, #40]
 2530 0062 1A70     		strb	r2, [r3]
 656:hardware/src/grey.c **** 				/*test*/
 657:hardware/src/grey.c **** 				testLineWidth = *lineWidth;
 2531              		.loc 1 657 21
 2532 0064 BB6A     		ldr	r3, [r7, #40]
 2533 0066 1A78     		ldrb	r2, [r3]	@ zero_extendqisi2
 2534              		.loc 1 657 19
 2535 0068 294B     		ldr	r3, .L132+4
 2536 006a 1A70     		strb	r2, [r3]
 658:hardware/src/grey.c **** 				return GOTLINEWIDTH;
 2537              		.loc 1 658 12
 2538 006c 2423     		movs	r3, #36
 2539 006e 48E0     		b	.L126
 2540              	.L125:
 2541              	.LBE10:
 649:hardware/src/grey.c **** 		{
 2542              		.loc 1 649 28 discriminator 2
 2543 0070 FB7D     		ldrb	r3, [r7, #23]	@ zero_extendqisi2
 2544 0072 0133     		adds	r3, r3, #1
 2545 0074 FB75     		strb	r3, [r7, #23]
 2546              	.L124:
ARM GAS  /tmp/ccBaawNW.s 			page 58


 649:hardware/src/grey.c **** 		{
 2547              		.loc 1 649 3 discriminator 1
 2548 0076 FA7D     		ldrb	r2, [r7, #23]	@ zero_extendqisi2
 2549 0078 FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 2550 007a 9A42     		cmp	r2, r3
 2551 007c D2D3     		bcc	.L127
 2552 007e 38E0     		b	.L128
 2553              	.L123:
 659:hardware/src/grey.c **** 			}
 660:hardware/src/grey.c **** 		}
 661:hardware/src/grey.c **** 	}
 662:hardware/src/grey.c **** 	else //右边的最小有效段较短，依据右边
 663:hardware/src/grey.c **** 	{
 664:hardware/src/grey.c **** 		for(i = 0;i < rMaxULen;i ++)//开始匹配同一水平位置左右均存在有效交点
 2554              		.loc 1 664 9
 2555 0080 0023     		movs	r3, #0
 2556 0082 FB75     		strb	r3, [r7, #23]
 2557              		.loc 1 664 3
 2558 0084 31E0     		b	.L129
 2559              	.L131:
 665:hardware/src/grey.c **** 		{
 666:hardware/src/grey.c **** 			if(leftBlackLoc[rMaxLineHei[i]] != 0)//在左边有效位置高度，存在右边有效线段交点
 2560              		.loc 1 666 31
 2561 0086 FB7D     		ldrb	r3, [r7, #23]	@ zero_extendqisi2
 2562 0088 7A6A     		ldr	r2, [r7, #36]
 2563 008a 1344     		add	r3, r3, r2
 2564 008c 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 2565 008e 1A46     		mov	r2, r3
 2566              		.loc 1 666 19
 2567 0090 204B     		ldr	r3, .L132+8
 2568 0092 9B5C     		ldrb	r3, [r3, r2]	@ zero_extendqisi2
 2569              		.loc 1 666 6
 2570 0094 002B     		cmp	r3, #0
 2571 0096 25D0     		beq	.L130
 667:hardware/src/grey.c **** 			if(leftBlackLoc[rMaxLineHei[i]/SKIPLINE] != 0)//在左边有效位置高度，存在右边有效线段交点
 2572              		.loc 1 667 31
 2573 0098 FB7D     		ldrb	r3, [r7, #23]	@ zero_extendqisi2
 2574 009a 7A6A     		ldr	r2, [r7, #36]
 2575 009c 1344     		add	r3, r3, r2
 2576 009e 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 2577              		.loc 1 667 34
 2578 00a0 9B08     		lsrs	r3, r3, #2
 2579 00a2 DBB2     		uxtb	r3, r3
 2580 00a4 1A46     		mov	r2, r3
 2581              		.loc 1 667 19
 2582 00a6 1B4B     		ldr	r3, .L132+8
 2583 00a8 9B5C     		ldrb	r3, [r3, r2]	@ zero_extendqisi2
 2584              		.loc 1 667 6
 2585 00aa 002B     		cmp	r3, #0
 2586 00ac 1AD0     		beq	.L130
 2587              	.LBB11:
 668:hardware/src/grey.c **** 			{
 669:hardware/src/grey.c **** 				// *lineWidth = abs(leftBlackLoc[rMaxLineHei[i]] - rMaxULine[i]);
 670:hardware/src/grey.c **** 				*lineWidth = abs(leftBlackLoc[rMaxLineHei[i]/SKIPLINE] - rMaxULine[i]);
 2588              		.loc 1 670 46
 2589 00ae FB7D     		ldrb	r3, [r7, #23]	@ zero_extendqisi2
 2590 00b0 7A6A     		ldr	r2, [r7, #36]
ARM GAS  /tmp/ccBaawNW.s 			page 59


 2591 00b2 1344     		add	r3, r3, r2
 2592 00b4 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 2593              		.loc 1 670 49
 2594 00b6 9B08     		lsrs	r3, r3, #2
 2595 00b8 DBB2     		uxtb	r3, r3
 2596 00ba 1A46     		mov	r2, r3
 2597              		.loc 1 670 34
 2598 00bc 154B     		ldr	r3, .L132+8
 2599 00be 9B5C     		ldrb	r3, [r3, r2]	@ zero_extendqisi2
 2600 00c0 1946     		mov	r1, r3
 2601              		.loc 1 670 71
 2602 00c2 FB7D     		ldrb	r3, [r7, #23]	@ zero_extendqisi2
 2603 00c4 BA68     		ldr	r2, [r7, #8]
 2604 00c6 1344     		add	r3, r3, r2
 2605 00c8 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 2606              		.loc 1 670 60
 2607 00ca CB1A     		subs	r3, r1, r3
 2608              		.loc 1 670 18
 2609 00cc 002B     		cmp	r3, #0
 2610 00ce B8BF     		it	lt
 2611 00d0 5B42     		rsblt	r3, r3, #0
 2612              		.loc 1 670 16
 2613 00d2 DAB2     		uxtb	r2, r3
 2614 00d4 BB6A     		ldr	r3, [r7, #40]
 2615 00d6 1A70     		strb	r2, [r3]
 671:hardware/src/grey.c **** 				/*test*/
 672:hardware/src/grey.c **** 				testLineWidth = *lineWidth;
 2616              		.loc 1 672 21
 2617 00d8 BB6A     		ldr	r3, [r7, #40]
 2618 00da 1A78     		ldrb	r2, [r3]	@ zero_extendqisi2
 2619              		.loc 1 672 19
 2620 00dc 0C4B     		ldr	r3, .L132+4
 2621 00de 1A70     		strb	r2, [r3]
 673:hardware/src/grey.c **** 				return GOTLINEWIDTH;
 2622              		.loc 1 673 12
 2623 00e0 2423     		movs	r3, #36
 2624 00e2 0EE0     		b	.L126
 2625              	.L130:
 2626              	.LBE11:
 664:hardware/src/grey.c **** 		{
 2627              		.loc 1 664 28 discriminator 2
 2628 00e4 FB7D     		ldrb	r3, [r7, #23]	@ zero_extendqisi2
 2629 00e6 0133     		adds	r3, r3, #1
 2630 00e8 FB75     		strb	r3, [r7, #23]
 2631              	.L129:
 664:hardware/src/grey.c **** 		{
 2632              		.loc 1 664 3 discriminator 1
 2633 00ea FA7D     		ldrb	r2, [r7, #23]	@ zero_extendqisi2
 2634 00ec BB79     		ldrb	r3, [r7, #6]	@ zero_extendqisi2
 2635 00ee 9A42     		cmp	r2, r3
 2636 00f0 C9D3     		bcc	.L131
 2637              	.L128:
 674:hardware/src/grey.c **** 			}
 675:hardware/src/grey.c **** 		}
 676:hardware/src/grey.c **** 	}
 677:hardware/src/grey.c **** 	//出错处理
 678:hardware/src/grey.c **** 	*lineWidth = 0;
ARM GAS  /tmp/ccBaawNW.s 			page 60


 2638              		.loc 1 678 13
 2639 00f2 BB6A     		ldr	r3, [r7, #40]
 2640 00f4 0022     		movs	r2, #0
 2641 00f6 1A70     		strb	r2, [r3]
 679:hardware/src/grey.c **** 	/*test*/
 680:hardware/src/grey.c **** 	testLineWidth = *lineWidth;
 2642              		.loc 1 680 18
 2643 00f8 BB6A     		ldr	r3, [r7, #40]
 2644 00fa 1A78     		ldrb	r2, [r3]	@ zero_extendqisi2
 2645              		.loc 1 680 16
 2646 00fc 044B     		ldr	r3, .L132+4
 2647 00fe 1A70     		strb	r2, [r3]
 681:hardware/src/grey.c **** 	return NOLINEWIDTH;
 2648              		.loc 1 681 9
 2649 0100 2523     		movs	r3, #37
 2650              	.L126:
 682:hardware/src/grey.c **** }
 2651              		.loc 1 682 1
 2652 0102 1846     		mov	r0, r3
 2653 0104 1C37     		adds	r7, r7, #28
 2654              	.LCFI43:
 2655              		.cfi_def_cfa_offset 4
 2656 0106 BD46     		mov	sp, r7
 2657              	.LCFI44:
 2658              		.cfi_def_cfa_register 13
 2659              		@ sp needed
 2660 0108 80BC     		pop	{r7}
 2661              	.LCFI45:
 2662              		.cfi_restore 7
 2663              		.cfi_def_cfa_offset 0
 2664 010a 7047     		bx	lr
 2665              	.L133:
 2666              		.align	2
 2667              	.L132:
 2668 010c 00000000 		.word	rightBlackLoc
 2669 0110 00000000 		.word	testLineWidth
 2670 0114 00000000 		.word	leftBlackLoc
 2671              		.cfi_endproc
 2672              	.LFE72:
 2674              		.section	.text.getLineLocCompare2MidLine,"ax",%progbits
 2675              		.align	1
 2676              		.global	getLineLocCompare2MidLine
 2677              		.syntax unified
 2678              		.thumb
 2679              		.thumb_func
 2680              		.fpu softvfp
 2682              	getLineLocCompare2MidLine:
 2683              	.LFB73:
 683:hardware/src/grey.c **** /*
 684:hardware/src/grey.c **** 函数功能：获取的是，当前检测到的直线（不论有没有倾斜），它相对于直线在屏幕中央的相对偏移
 685:hardware/src/grey.c **** 左偏为负，正偏为正
 686:hardware/src/grey.c **** 思路：首先滤除左右边界一开始的0点
 687:hardware/src/grey.c **** 然后，使用获取最长有效段的函数接口，获得两个边界的最长有效段
 688:hardware/src/grey.c **** 然后，依据比较短的最长有效段，计算出当前的线宽
 689:hardware/src/grey.c **** 再用中点位置，和一边的距离，整合线宽就可以计算出偏移量了。
 690:hardware/src/grey.c **** */
 691:hardware/src/grey.c **** int getLineLocCompare2MidLine(int *realVerticalDevationLoc)//传入用于返回的变量，为相对的偏移量
ARM GAS  /tmp/ccBaawNW.s 			page 61


 692:hardware/src/grey.c **** {
 2684              		.loc 1 692 1
 2685              		.cfi_startproc
 2686              		@ args = 0, pretend = 0, frame = 104
 2687              		@ frame_needed = 1, uses_anonymous_args = 0
 2688 0000 90B5     		push	{r4, r7, lr}
 2689              	.LCFI46:
 2690              		.cfi_def_cfa_offset 12
 2691              		.cfi_offset 4, -12
 2692              		.cfi_offset 7, -8
 2693              		.cfi_offset 14, -4
 2694 0002 9FB0     		sub	sp, sp, #124
 2695              	.LCFI47:
 2696              		.cfi_def_cfa_offset 136
 2697 0004 04AF     		add	r7, sp, #16
 2698              	.LCFI48:
 2699              		.cfi_def_cfa 7, 120
 2700 0006 7860     		str	r0, [r7, #4]
 693:hardware/src/grey.c **** 	u8 i = 0;
 2701              		.loc 1 693 5
 2702 0008 0023     		movs	r3, #0
 2703 000a 87F86730 		strb	r3, [r7, #103]
 694:hardware/src/grey.c **** 	u8 j = 0;
 2704              		.loc 1 694 5
 2705 000e 0023     		movs	r3, #0
 2706 0010 87F86230 		strb	r3, [r7, #98]
 695:hardware/src/grey.c **** 	u8 k = 0;
 2707              		.loc 1 695 5
 2708 0014 0023     		movs	r3, #0
 2709 0016 87F86130 		strb	r3, [r7, #97]
 696:hardware/src/grey.c **** 	u8 res = 0;
 2710              		.loc 1 696 5
 2711 001a 0023     		movs	r3, #0
 2712 001c 87F86030 		strb	r3, [r7, #96]
 697:hardware/src/grey.c **** /*保存临时的左右最长有效边界的数组*/
 698:hardware/src/grey.c **** 	u8 leftMaxULineLoc[((NEEDHEIGHT)/(SKIPLINE))] = {0};
 2713              		.loc 1 698 5
 2714 0020 0023     		movs	r3, #0
 2715 0022 FB64     		str	r3, [r7, #76]
 2716 0024 07F15003 		add	r3, r7, #80
 2717 0028 0022     		movs	r2, #0
 2718 002a 1A60     		str	r2, [r3]
 2719 002c 5A60     		str	r2, [r3, #4]
 2720 002e 9A60     		str	r2, [r3, #8]
 2721 0030 DA60     		str	r2, [r3, #12]
 699:hardware/src/grey.c **** 	u8 rightMaxULineLoc[((NEEDHEIGHT)/(SKIPLINE))] = {0};
 2722              		.loc 1 699 5
 2723 0032 0023     		movs	r3, #0
 2724 0034 BB63     		str	r3, [r7, #56]
 2725 0036 07F13C03 		add	r3, r7, #60
 2726 003a 0022     		movs	r2, #0
 2727 003c 1A60     		str	r2, [r3]
 2728 003e 5A60     		str	r2, [r3, #4]
 2729 0040 9A60     		str	r2, [r3, #8]
 2730 0042 DA60     		str	r2, [r3, #12]
 700:hardware/src/grey.c **** 	//最长长度
 701:hardware/src/grey.c **** 	u8 leftMaxULen = 0;
ARM GAS  /tmp/ccBaawNW.s 			page 62


 2731              		.loc 1 701 5
 2732 0044 0023     		movs	r3, #0
 2733 0046 87F83730 		strb	r3, [r7, #55]
 702:hardware/src/grey.c **** 	u8 rightMaxULen = 0;
 2734              		.loc 1 702 5
 2735 004a 0023     		movs	r3, #0
 2736 004c 87F83630 		strb	r3, [r7, #54]
 703:hardware/src/grey.c **** 	//有效段的高度位置
 704:hardware/src/grey.c **** 	u8 leftMaxUBlackHeight[((NEEDHEIGHT)/(SKIPLINE))] = {0};
 2737              		.loc 1 704 5
 2738 0050 0023     		movs	r3, #0
 2739 0052 3B62     		str	r3, [r7, #32]
 2740 0054 07F12403 		add	r3, r7, #36
 2741 0058 0022     		movs	r2, #0
 2742 005a 1A60     		str	r2, [r3]
 2743 005c 5A60     		str	r2, [r3, #4]
 2744 005e 9A60     		str	r2, [r3, #8]
 2745 0060 DA60     		str	r2, [r3, #12]
 705:hardware/src/grey.c **** 	u8 rightMaxUBlackHeight[((NEEDHEIGHT)/(SKIPLINE))] = {0};
 2746              		.loc 1 705 5
 2747 0062 0023     		movs	r3, #0
 2748 0064 FB60     		str	r3, [r7, #12]
 2749 0066 07F11003 		add	r3, r7, #16
 2750 006a 0022     		movs	r2, #0
 2751 006c 1A60     		str	r2, [r3]
 2752 006e 5A60     		str	r2, [r3, #4]
 2753 0070 9A60     		str	r2, [r3, #8]
 2754 0072 DA60     		str	r2, [r3, #12]
 706:hardware/src/grey.c **** 	//当前线宽
 707:hardware/src/grey.c **** 	u8 lineWidth = 0;
 2755              		.loc 1 707 5
 2756 0074 0023     		movs	r3, #0
 2757 0076 FB72     		strb	r3, [r7, #11]
 708:hardware/src/grey.c **** /******预先对左右边界进行处理，如果没有检测到就必须返回，结束此函数*****/
 709:hardware/src/grey.c **** /*首先将段开始的无用数据滤除*/
 710:hardware/src/grey.c **** 	//默认边界没有找到
 711:hardware/src/grey.c **** 	u8 LeftDirect = LEFTLOST;
 2758              		.loc 1 711 5
 2759 0078 0723     		movs	r3, #7
 2760 007a 87F86630 		strb	r3, [r7, #102]
 712:hardware/src/grey.c **** 	u8 RightDirect = RIGHTLOST;
 2761              		.loc 1 712 5
 2762 007e 0823     		movs	r3, #8
 2763 0080 87F86530 		strb	r3, [r7, #101]
 713:hardware/src/grey.c **** 	/*临时变量*/
 714:hardware/src/grey.c **** 	u8 countLeftZero = 0;//统计一个边界中的0的无用数据个数的临时变量
 2764              		.loc 1 714 5
 2765 0084 0023     		movs	r3, #0
 2766 0086 87F86430 		strb	r3, [r7, #100]
 715:hardware/src/grey.c **** 	u8 countRightZero = 0;//统计一个边界中的0的无用数据个数的临时变量
 2767              		.loc 1 715 5
 2768 008a 0023     		movs	r3, #0
 2769 008c 87F86330 		strb	r3, [r7, #99]
 716:hardware/src/grey.c **** 	u8 left_nums,right_nums;
 717:hardware/src/grey.c **** 	/*左边滤除数组开始的0操作*/
 718:hardware/src/grey.c **** 	while((countLeftZero < 20) && (leftBlackLoc[countLeftZero] == 0))
 2770              		.loc 1 718 7
ARM GAS  /tmp/ccBaawNW.s 			page 63


 2771 0090 04E0     		b	.L135
 2772              	.L137:
 719:hardware/src/grey.c **** 	{ countLeftZero ++;}//下一个数据
 2773              		.loc 1 719 18
 2774 0092 97F86430 		ldrb	r3, [r7, #100]	@ zero_extendqisi2
 2775 0096 0133     		adds	r3, r3, #1
 2776 0098 87F86430 		strb	r3, [r7, #100]
 2777              	.L135:
 718:hardware/src/grey.c **** 	{ countLeftZero ++;}//下一个数据
 2778              		.loc 1 718 7
 2779 009c 97F86430 		ldrb	r3, [r7, #100]	@ zero_extendqisi2
 2780 00a0 132B     		cmp	r3, #19
 2781 00a2 05D8     		bhi	.L136
 718:hardware/src/grey.c **** 	{ countLeftZero ++;}//下一个数据
 2782              		.loc 1 718 45 discriminator 1
 2783 00a4 97F86430 		ldrb	r3, [r7, #100]	@ zero_extendqisi2
 2784 00a8 AE4A     		ldr	r2, .L161
 2785 00aa D35C     		ldrb	r3, [r2, r3]	@ zero_extendqisi2
 718:hardware/src/grey.c **** 	{ countLeftZero ++;}//下一个数据
 2786              		.loc 1 718 29 discriminator 1
 2787 00ac 002B     		cmp	r3, #0
 2788 00ae F0D0     		beq	.L137
 2789              	.L136:
 720:hardware/src/grey.c **** 	if(countLeftZero == 20)//如果全部为0，那么就是没有边界，直接将标志位置为lost丢失
 2790              		.loc 1 720 4
 2791 00b0 97F86430 		ldrb	r3, [r7, #100]	@ zero_extendqisi2
 2792 00b4 142B     		cmp	r3, #20
 2793 00b6 03D1     		bne	.L138
 721:hardware/src/grey.c **** 	{LeftDirect = LEFTLOST;}
 2794              		.loc 1 721 14
 2795 00b8 0723     		movs	r3, #7
 2796 00ba 87F86630 		strb	r3, [r7, #102]
 2797 00be 08E0     		b	.L140
 2798              	.L138:
 722:hardware/src/grey.c **** 	else{LeftDirect = GETDIRECT;}
 2799              		.loc 1 722 18
 2800 00c0 0923     		movs	r3, #9
 2801 00c2 87F86630 		strb	r3, [r7, #102]
 723:hardware/src/grey.c **** 	/*右边滤除0操作*/
 724:hardware/src/grey.c **** 	while((countRightZero < 20) && (rightBlackLoc[countRightZero] == 0))
 2802              		.loc 1 724 7
 2803 00c6 04E0     		b	.L140
 2804              	.L142:
 725:hardware/src/grey.c **** 	{countRightZero ++;}//下一个数据
 2805              		.loc 1 725 18
 2806 00c8 97F86330 		ldrb	r3, [r7, #99]	@ zero_extendqisi2
 2807 00cc 0133     		adds	r3, r3, #1
 2808 00ce 87F86330 		strb	r3, [r7, #99]
 2809              	.L140:
 724:hardware/src/grey.c **** 	{countRightZero ++;}//下一个数据
 2810              		.loc 1 724 7
 2811 00d2 97F86330 		ldrb	r3, [r7, #99]	@ zero_extendqisi2
 2812 00d6 132B     		cmp	r3, #19
 2813 00d8 05D8     		bhi	.L141
 724:hardware/src/grey.c **** 	{countRightZero ++;}//下一个数据
 2814              		.loc 1 724 47 discriminator 1
 2815 00da 97F86330 		ldrb	r3, [r7, #99]	@ zero_extendqisi2
ARM GAS  /tmp/ccBaawNW.s 			page 64


 2816 00de A24A     		ldr	r2, .L161+4
 2817 00e0 D35C     		ldrb	r3, [r2, r3]	@ zero_extendqisi2
 724:hardware/src/grey.c **** 	{countRightZero ++;}//下一个数据
 2818              		.loc 1 724 30 discriminator 1
 2819 00e2 002B     		cmp	r3, #0
 2820 00e4 F0D0     		beq	.L142
 2821              	.L141:
 726:hardware/src/grey.c **** 	if(countRightZero == 20)//如果全部为0，那么就是没有边界，直接将标志位置为lost丢失
 2822              		.loc 1 726 4
 2823 00e6 97F86330 		ldrb	r3, [r7, #99]	@ zero_extendqisi2
 2824 00ea 142B     		cmp	r3, #20
 2825 00ec 03D1     		bne	.L143
 727:hardware/src/grey.c **** 	{RightDirect = RIGHTLOST;}
 2826              		.loc 1 727 15
 2827 00ee 0823     		movs	r3, #8
 2828 00f0 87F86530 		strb	r3, [r7, #101]
 2829 00f4 02E0     		b	.L144
 2830              	.L143:
 728:hardware/src/grey.c **** 	else{RightDirect = GETDIRECT;}
 2831              		.loc 1 728 19
 2832 00f6 0923     		movs	r3, #9
 2833 00f8 87F86530 		strb	r3, [r7, #101]
 2834              	.L144:
 729:hardware/src/grey.c **** 	//均丢失，那么就直接结束函数
 730:hardware/src/grey.c **** 	if((LeftDirect == LEFTLOST) && (RightDirect == RIGHTLOST))
 2835              		.loc 1 730 4
 2836 00fc 97F86630 		ldrb	r3, [r7, #102]	@ zero_extendqisi2
 2837 0100 072B     		cmp	r3, #7
 2838 0102 05D1     		bne	.L145
 2839              		.loc 1 730 30 discriminator 1
 2840 0104 97F86530 		ldrb	r3, [r7, #101]	@ zero_extendqisi2
 2841 0108 082B     		cmp	r3, #8
 2842 010a 01D1     		bne	.L145
 731:hardware/src/grey.c **** 	{
 732:hardware/src/grey.c **** 		return BOTHLOST;//只返回丢失信号，不做偏移量复制
 2843              		.loc 1 732 10
 2844 010c 0A23     		movs	r3, #10
 2845 010e 25E1     		b	.L160
 2846              	.L145:
 733:hardware/src/grey.c **** 	}
 734:hardware/src/grey.c **** /***********************************************************************/
 735:hardware/src/grey.c **** 	/*没有检测到左边的边界 那么就是太偏左了，这时根本确定不了偏移量，只能返回设置的最大值*/
 736:hardware/src/grey.c **** 	if((LeftDirect == LEFTLOST) && (RightDirect == GETDIRECT))
 2847              		.loc 1 736 4
 2848 0110 97F86630 		ldrb	r3, [r7, #102]	@ zero_extendqisi2
 2849 0114 072B     		cmp	r3, #7
 2850 0116 0FD1     		bne	.L147
 2851              		.loc 1 736 30 discriminator 1
 2852 0118 97F86530 		ldrb	r3, [r7, #101]	@ zero_extendqisi2
 2853 011c 092B     		cmp	r3, #9
 2854 011e 0BD1     		bne	.L147
 737:hardware/src/grey.c **** 	{
 738:hardware/src/grey.c **** 		*realVerticalDevationLoc = rightBlackLoc[countRightZero]/2-NEEDWITH/2;
 2855              		.loc 1 738 43
 2856 0120 97F86330 		ldrb	r3, [r7, #99]	@ zero_extendqisi2
 2857 0124 904A     		ldr	r2, .L161+4
 2858 0126 D35C     		ldrb	r3, [r2, r3]	@ zero_extendqisi2
ARM GAS  /tmp/ccBaawNW.s 			page 65


 2859              		.loc 1 738 59
 2860 0128 5B08     		lsrs	r3, r3, #1
 2861 012a DBB2     		uxtb	r3, r3
 2862              		.loc 1 738 61
 2863 012c A3F13C02 		sub	r2, r3, #60
 2864              		.loc 1 738 28
 2865 0130 7B68     		ldr	r3, [r7, #4]
 2866 0132 1A60     		str	r2, [r3]
 739:hardware/src/grey.c **** 		return TOOLEFT;
 2867              		.loc 1 739 10
 2868 0134 1623     		movs	r3, #22
 2869 0136 11E1     		b	.L160
 2870              	.L147:
 740:hardware/src/grey.c **** 	}
 741:hardware/src/grey.c **** 	/*没有检测到右边的边界*/
 742:hardware/src/grey.c **** 	if((LeftDirect == GETDIRECT) && (RightDirect == RIGHTLOST))
 2871              		.loc 1 742 4
 2872 0138 97F86630 		ldrb	r3, [r7, #102]	@ zero_extendqisi2
 2873 013c 092B     		cmp	r3, #9
 2874 013e 11D1     		bne	.L148
 2875              		.loc 1 742 31 discriminator 1
 2876 0140 97F86530 		ldrb	r3, [r7, #101]	@ zero_extendqisi2
 2877 0144 082B     		cmp	r3, #8
 2878 0146 0DD1     		bne	.L148
 743:hardware/src/grey.c **** 	{
 744:hardware/src/grey.c **** 		*realVerticalDevationLoc = (leftBlackLoc[countLeftZero]+NEEDWITH)/2 - NEEDWITH/2;
 2879              		.loc 1 744 43
 2880 0148 97F86430 		ldrb	r3, [r7, #100]	@ zero_extendqisi2
 2881 014c 854A     		ldr	r2, .L161
 2882 014e D35C     		ldrb	r3, [r2, r3]	@ zero_extendqisi2
 2883              		.loc 1 744 58
 2884 0150 7833     		adds	r3, r3, #120
 2885              		.loc 1 744 68
 2886 0152 DA0F     		lsrs	r2, r3, #31
 2887 0154 1344     		add	r3, r3, r2
 2888 0156 5B10     		asrs	r3, r3, #1
 2889              		.loc 1 744 71
 2890 0158 A3F13C02 		sub	r2, r3, #60
 2891              		.loc 1 744 28
 2892 015c 7B68     		ldr	r3, [r7, #4]
 2893 015e 1A60     		str	r2, [r3]
 745:hardware/src/grey.c **** 		return TOORIGHT;
 2894              		.loc 1 745 10
 2895 0160 1723     		movs	r3, #23
 2896 0162 FBE0     		b	.L160
 2897              	.L148:
 746:hardware/src/grey.c **** 	}
 747:hardware/src/grey.c **** 	/*************************以下均为有两边边界的*********************************/
 748:hardware/src/grey.c **** 	
 749:hardware/src/grey.c **** 	/*如果检测到了左右边界，再分一下几种情况*/
 750:hardware/src/grey.c **** 	//首先采集一次左右边界的有效段。
 751:hardware/src/grey.c **** 	getOneSideUsefulLine(leftBlackLoc,countLeftZero,leftMaxULineLoc,&leftMaxULen,leftMaxUBlackHeight);
 2898              		.loc 1 751 2
 2899 0164 07F13700 		add	r0, r7, #55
 2900 0168 07F14C02 		add	r2, r7, #76
 2901 016c 97F86410 		ldrb	r1, [r7, #100]	@ zero_extendqisi2
 2902 0170 07F12003 		add	r3, r7, #32
ARM GAS  /tmp/ccBaawNW.s 			page 66


 2903 0174 0093     		str	r3, [sp]
 2904 0176 0346     		mov	r3, r0
 2905 0178 7A48     		ldr	r0, .L161
 2906 017a FFF7FEFF 		bl	getOneSideUsefulLine
 752:hardware/src/grey.c **** 	getOneSideUsefulLine(rightBlackLoc,countRightZero,rightMaxULineLoc,&rightMaxULen,rightMaxUBlackHei
 2907              		.loc 1 752 2
 2908 017e 07F13600 		add	r0, r7, #54
 2909 0182 07F13802 		add	r2, r7, #56
 2910 0186 97F86310 		ldrb	r1, [r7, #99]	@ zero_extendqisi2
 2911 018a 07F10C03 		add	r3, r7, #12
 2912 018e 0093     		str	r3, [sp]
 2913 0190 0346     		mov	r3, r0
 2914 0192 7548     		ldr	r0, .L161+4
 2915 0194 FFF7FEFF 		bl	getOneSideUsefulLine
 753:hardware/src/grey.c **** 	//那么现在leftMaxULineLoc leftMaxULen 和 rightMaxULineLoc  rightMaxULen中已经可以使用了
 754:hardware/src/grey.c **** 	//过滤有效段太短的边界，直接返回太偏左偏右即可
 755:hardware/src/grey.c **** 	if((leftMaxULen <= 2)){
 2916              		.loc 1 755 18
 2917 0198 97F83730 		ldrb	r3, [r7, #55]	@ zero_extendqisi2
 2918              		.loc 1 755 4
 2919 019c 022B     		cmp	r3, #2
 2920 019e 0BD8     		bhi	.L149
 756:hardware/src/grey.c **** 		*realVerticalDevationLoc = rightBlackLoc[countRightZero]/2-NEEDWITH/2;
 2921              		.loc 1 756 43
 2922 01a0 97F86330 		ldrb	r3, [r7, #99]	@ zero_extendqisi2
 2923 01a4 704A     		ldr	r2, .L161+4
 2924 01a6 D35C     		ldrb	r3, [r2, r3]	@ zero_extendqisi2
 2925              		.loc 1 756 59
 2926 01a8 5B08     		lsrs	r3, r3, #1
 2927 01aa DBB2     		uxtb	r3, r3
 2928              		.loc 1 756 61
 2929 01ac A3F13C02 		sub	r2, r3, #60
 2930              		.loc 1 756 28
 2931 01b0 7B68     		ldr	r3, [r7, #4]
 2932 01b2 1A60     		str	r2, [r3]
 757:hardware/src/grey.c **** 		return TOOLEFT;
 2933              		.loc 1 757 10
 2934 01b4 1623     		movs	r3, #22
 2935 01b6 D1E0     		b	.L160
 2936              	.L149:
 758:hardware/src/grey.c **** 	}
 759:hardware/src/grey.c **** 	if((rightMaxULen <= 2)){
 2937              		.loc 1 759 19
 2938 01b8 97F83630 		ldrb	r3, [r7, #54]	@ zero_extendqisi2
 2939              		.loc 1 759 4
 2940 01bc 022B     		cmp	r3, #2
 2941 01be 0DD8     		bhi	.L150
 760:hardware/src/grey.c **** 		*realVerticalDevationLoc = (leftBlackLoc[countLeftZero]+NEEDWITH)/2 - NEEDWITH/2;
 2942              		.loc 1 760 43
 2943 01c0 97F86430 		ldrb	r3, [r7, #100]	@ zero_extendqisi2
 2944 01c4 674A     		ldr	r2, .L161
 2945 01c6 D35C     		ldrb	r3, [r2, r3]	@ zero_extendqisi2
 2946              		.loc 1 760 58
 2947 01c8 7833     		adds	r3, r3, #120
 2948              		.loc 1 760 68
 2949 01ca DA0F     		lsrs	r2, r3, #31
 2950 01cc 1344     		add	r3, r3, r2
ARM GAS  /tmp/ccBaawNW.s 			page 67


 2951 01ce 5B10     		asrs	r3, r3, #1
 2952              		.loc 1 760 71
 2953 01d0 A3F13C02 		sub	r2, r3, #60
 2954              		.loc 1 760 28
 2955 01d4 7B68     		ldr	r3, [r7, #4]
 2956 01d6 1A60     		str	r2, [r3]
 761:hardware/src/grey.c **** 		return TOORIGHT;
 2957              		.loc 1 761 10
 2958 01d8 1723     		movs	r3, #23
 2959 01da BFE0     		b	.L160
 2960              	.L150:
 762:hardware/src/grey.c **** 	}
 763:hardware/src/grey.c **** 	/*获得线宽*/
 764:hardware/src/grey.c **** 	res = getLineWidth(leftMaxULineLoc,rightMaxULineLoc,leftMaxULen,rightMaxULen,leftMaxUBlackHeight,r
 2961              		.loc 1 764 8
 2962 01dc 97F83720 		ldrb	r2, [r7, #55]	@ zero_extendqisi2
 2963 01e0 97F83640 		ldrb	r4, [r7, #54]	@ zero_extendqisi2
 2964 01e4 07F13801 		add	r1, r7, #56
 2965 01e8 07F14C00 		add	r0, r7, #76
 2966 01ec 07F10B03 		add	r3, r7, #11
 2967 01f0 0293     		str	r3, [sp, #8]
 2968 01f2 07F10C03 		add	r3, r7, #12
 2969 01f6 0193     		str	r3, [sp, #4]
 2970 01f8 07F12003 		add	r3, r7, #32
 2971 01fc 0093     		str	r3, [sp]
 2972 01fe 2346     		mov	r3, r4
 2973 0200 FFF7FEFF 		bl	getLineWidth
 2974 0204 0346     		mov	r3, r0
 2975              		.loc 1 764 6
 2976 0206 87F86030 		strb	r3, [r7, #96]
 765:hardware/src/grey.c **** 	if(res == NOLINEWIDTH)//如果没有获取到线宽
 2977              		.loc 1 765 4
 2978 020a 97F86030 		ldrb	r3, [r7, #96]	@ zero_extendqisi2
 2979 020e 252B     		cmp	r3, #37
 2980 0210 06D1     		bne	.L151
 766:hardware/src/grey.c **** 	{
 767:hardware/src/grey.c **** 		lineWidth = 0;
 2981              		.loc 1 767 13
 2982 0212 0023     		movs	r3, #0
 2983 0214 FB72     		strb	r3, [r7, #11]
 768:hardware/src/grey.c **** 		*realVerticalDevationLoc = 0;
 2984              		.loc 1 768 28
 2985 0216 7B68     		ldr	r3, [r7, #4]
 2986 0218 0022     		movs	r2, #0
 2987 021a 1A60     		str	r2, [r3]
 769:hardware/src/grey.c **** 		return NOLINEWIDTH;
 2988              		.loc 1 769 10
 2989 021c 2523     		movs	r3, #37
 2990 021e 9DE0     		b	.L160
 2991              	.L151:
 770:hardware/src/grey.c **** 	}
 771:hardware/src/grey.c **** 	/*开始使用整个屏幕中点去计算偏移，默认肯定检测到了两边*/
 772:hardware/src/grey.c **** 	//从左边开始
 773:hardware/src/grey.c **** 	for(i = 0;i < leftMaxULen;i ++)
 2992              		.loc 1 773 8
 2993 0220 0023     		movs	r3, #0
 2994 0222 87F86730 		strb	r3, [r7, #103]
ARM GAS  /tmp/ccBaawNW.s 			page 68


 2995              		.loc 1 773 2
 2996 0226 43E0     		b	.L152
 2997              	.L155:
 774:hardware/src/grey.c **** 	{
 775:hardware/src/grey.c **** 		// if(leftMaxUBlackHeight[i] == MIDHORIHEIGHT)//发现左边与水平中线有交点
 776:hardware/src/grey.c **** 		if(leftMaxUBlackHeight[i]/SKIPLINE == MIDHORIHEIGHT)//发现左边与水平中线有交点
 2998              		.loc 1 776 25
 2999 0228 97F86730 		ldrb	r3, [r7, #103]	@ zero_extendqisi2
 3000 022c 07F16802 		add	r2, r7, #104
 3001 0230 1344     		add	r3, r3, r2
 3002 0232 13F8483C 		ldrb	r3, [r3, #-72]	@ zero_extendqisi2
 3003              		.loc 1 776 38
 3004 0236 243B     		subs	r3, r3, #36
 3005 0238 DBB2     		uxtb	r3, r3
 3006              		.loc 1 776 5
 3007 023a 032B     		cmp	r3, #3
 3008 023c 33D8     		bhi	.L153
 777:hardware/src/grey.c **** 		{
 778:hardware/src/grey.c **** #if defined(DEBUG_CAMERA) && DEBUG_CAMERA
 779:hardware/src/grey.c **** 			printf("%d:width/2:%d,leftloc:%d\r\n",i,(lineWidth / 2),leftMaxULineLoc[i]);
 780:hardware/src/grey.c **** 			for(k=0;k<leftMaxULen;k++){
 781:hardware/src/grey.c **** 				printf("%d:%d_%d ",k,leftMaxULineLoc[i],leftMaxUBlackHeight[k]);
 782:hardware/src/grey.c **** 			}
 783:hardware/src/grey.c **** 			printf("\r\n");
 784:hardware/src/grey.c **** #endif
 785:hardware/src/grey.c **** 			/*根据直线位于中点的四个位置，获得的两种式子，两个式子结果互为相反数*/
 786:hardware/src/grey.c **** 		
 787:hardware/src/grey.c **** 			//则整个线都偏右，结果为正！
 788:hardware/src/grey.c **** 			if((leftMaxULineLoc[i] + (lineWidth / 2)) > MIDHORLOC)
 3009              		.loc 1 788 23
 3010 023e 97F86730 		ldrb	r3, [r7, #103]	@ zero_extendqisi2
 3011 0242 07F16802 		add	r2, r7, #104
 3012 0246 1344     		add	r3, r3, r2
 3013 0248 13F81C3C 		ldrb	r3, [r3, #-28]	@ zero_extendqisi2
 3014 024c 1A46     		mov	r2, r3
 3015              		.loc 1 788 40
 3016 024e FB7A     		ldrb	r3, [r7, #11]	@ zero_extendqisi2
 3017 0250 5B08     		lsrs	r3, r3, #1
 3018 0252 DBB2     		uxtb	r3, r3
 3019              		.loc 1 788 27
 3020 0254 1344     		add	r3, r3, r2
 3021              		.loc 1 788 6
 3022 0256 3B2B     		cmp	r3, #59
 3023 0258 0FDD     		ble	.L154
 789:hardware/src/grey.c **** 			{
 790:hardware/src/grey.c **** 				*realVerticalDevationLoc = (lineWidth / 2) - MIDHORLOC + leftMaxULineLoc[i];
 3024              		.loc 1 790 43
 3025 025a FB7A     		ldrb	r3, [r7, #11]	@ zero_extendqisi2
 3026 025c 5B08     		lsrs	r3, r3, #1
 3027 025e DBB2     		uxtb	r3, r3
 3028              		.loc 1 790 48
 3029 0260 3B3B     		subs	r3, r3, #59
 3030              		.loc 1 790 77
 3031 0262 97F86720 		ldrb	r2, [r7, #103]	@ zero_extendqisi2
 3032 0266 07F16801 		add	r1, r7, #104
 3033 026a 0A44     		add	r2, r2, r1
 3034 026c 12F81C2C 		ldrb	r2, [r2, #-28]	@ zero_extendqisi2
ARM GAS  /tmp/ccBaawNW.s 			page 69


 3035              		.loc 1 790 60
 3036 0270 1A44     		add	r2, r2, r3
 3037              		.loc 1 790 30
 3038 0272 7B68     		ldr	r3, [r7, #4]
 3039 0274 1A60     		str	r2, [r3]
 791:hardware/src/grey.c **** 				return GETMIDLOC;
 3040              		.loc 1 791 12
 3041 0276 1823     		movs	r3, #24
 3042 0278 70E0     		b	.L160
 3043              	.L154:
 792:hardware/src/grey.c **** 			}
 793:hardware/src/grey.c **** 			else  //整个线都偏左，结果为负
 794:hardware/src/grey.c **** 			{
 795:hardware/src/grey.c **** 				//正值的偏移量
 796:hardware/src/grey.c **** 				*realVerticalDevationLoc = MIDHORLOC - leftMaxULineLoc[i] - (lineWidth / 2);
 3044              		.loc 1 796 59
 3045 027a 97F86730 		ldrb	r3, [r7, #103]	@ zero_extendqisi2
 3046 027e 07F16802 		add	r2, r7, #104
 3047 0282 1344     		add	r3, r3, r2
 3048 0284 13F81C3C 		ldrb	r3, [r3, #-28]	@ zero_extendqisi2
 3049              		.loc 1 796 42
 3050 0288 C3F13B03 		rsb	r3, r3, #59
 3051              		.loc 1 796 76
 3052 028c FA7A     		ldrb	r2, [r7, #11]	@ zero_extendqisi2
 3053 028e 5208     		lsrs	r2, r2, #1
 3054 0290 D2B2     		uxtb	r2, r2
 3055              		.loc 1 796 63
 3056 0292 9A1A     		subs	r2, r3, r2
 3057              		.loc 1 796 30
 3058 0294 7B68     		ldr	r3, [r7, #4]
 3059 0296 1A60     		str	r2, [r3]
 797:hardware/src/grey.c **** 				*realVerticalDevationLoc = 0 - *realVerticalDevationLoc;//取反以后，返回为负值，表示为左偏
 3060              		.loc 1 797 36
 3061 0298 7B68     		ldr	r3, [r7, #4]
 3062 029a 1B68     		ldr	r3, [r3]
 3063              		.loc 1 797 34
 3064 029c 5A42     		rsbs	r2, r3, #0
 3065              		.loc 1 797 30
 3066 029e 7B68     		ldr	r3, [r7, #4]
 3067 02a0 1A60     		str	r2, [r3]
 798:hardware/src/grey.c **** 				return GETMIDLOC;
 3068              		.loc 1 798 12
 3069 02a2 1823     		movs	r3, #24
 3070 02a4 5AE0     		b	.L160
 3071              	.L153:
 773:hardware/src/grey.c **** 	{
 3072              		.loc 1 773 30 discriminator 2
 3073 02a6 97F86730 		ldrb	r3, [r7, #103]	@ zero_extendqisi2
 3074 02aa 0133     		adds	r3, r3, #1
 3075 02ac 87F86730 		strb	r3, [r7, #103]
 3076              	.L152:
 773:hardware/src/grey.c **** 	{
 3077              		.loc 1 773 14 discriminator 1
 3078 02b0 97F83730 		ldrb	r3, [r7, #55]	@ zero_extendqisi2
 773:hardware/src/grey.c **** 	{
 3079              		.loc 1 773 2 discriminator 1
 3080 02b4 97F86720 		ldrb	r2, [r7, #103]	@ zero_extendqisi2
ARM GAS  /tmp/ccBaawNW.s 			page 70


 3081 02b8 9A42     		cmp	r2, r3
 3082 02ba B5D3     		bcc	.L155
 799:hardware/src/grey.c **** 			}
 800:hardware/src/grey.c **** 		}
 801:hardware/src/grey.c **** 	}
 802:hardware/src/grey.c **** 	/*再做右边*/
 803:hardware/src/grey.c **** 	for(i = 0;i < rightMaxULen;i ++)
 3083              		.loc 1 803 8
 3084 02bc 0023     		movs	r3, #0
 3085 02be 87F86730 		strb	r3, [r7, #103]
 3086              		.loc 1 803 2
 3087 02c2 44E0     		b	.L156
 3088              	.L159:
 804:hardware/src/grey.c **** 	{
 805:hardware/src/grey.c **** 		// if(rightMaxUBlackHeight[i] == MIDHORIHEIGHT)//发现左边与水平中线有交点
 806:hardware/src/grey.c **** 		if(rightMaxUBlackHeight[i]/SKIPLINE == MIDHORIHEIGHT)//发现左边与水平中线有交点
 3089              		.loc 1 806 26
 3090 02c4 97F86730 		ldrb	r3, [r7, #103]	@ zero_extendqisi2
 3091 02c8 07F16802 		add	r2, r7, #104
 3092 02cc 1344     		add	r3, r3, r2
 3093 02ce 13F85C3C 		ldrb	r3, [r3, #-92]	@ zero_extendqisi2
 3094              		.loc 1 806 39
 3095 02d2 243B     		subs	r3, r3, #36
 3096 02d4 DBB2     		uxtb	r3, r3
 3097              		.loc 1 806 5
 3098 02d6 032B     		cmp	r3, #3
 3099 02d8 34D8     		bhi	.L157
 807:hardware/src/grey.c **** 		{
 808:hardware/src/grey.c **** 			/*根据直线位于中点的四个位置，获得的两种式子，两个式子结果互为相反数*/
 809:hardware/src/grey.c **** 			//黑线偏右
 810:hardware/src/grey.c **** 			if((rightMaxULineLoc[i] + (lineWidth / 2)) > MIDHORLOC)
 3100              		.loc 1 810 24
 3101 02da 97F86730 		ldrb	r3, [r7, #103]	@ zero_extendqisi2
 3102 02de 07F16802 		add	r2, r7, #104
 3103 02e2 1344     		add	r3, r3, r2
 3104 02e4 13F8303C 		ldrb	r3, [r3, #-48]	@ zero_extendqisi2
 3105 02e8 1A46     		mov	r2, r3
 3106              		.loc 1 810 41
 3107 02ea FB7A     		ldrb	r3, [r7, #11]	@ zero_extendqisi2
 3108 02ec 5B08     		lsrs	r3, r3, #1
 3109 02ee DBB2     		uxtb	r3, r3
 3110              		.loc 1 810 28
 3111 02f0 1344     		add	r3, r3, r2
 3112              		.loc 1 810 6
 3113 02f2 3B2B     		cmp	r3, #59
 3114 02f4 0FDD     		ble	.L158
 811:hardware/src/grey.c **** 			{
 812:hardware/src/grey.c **** 				*realVerticalDevationLoc = rightMaxULineLoc[i] - MIDHORLOC - (lineWidth / 2);
 3115              		.loc 1 812 48
 3116 02f6 97F86730 		ldrb	r3, [r7, #103]	@ zero_extendqisi2
 3117 02fa 07F16802 		add	r2, r7, #104
 3118 02fe 1344     		add	r3, r3, r2
 3119 0300 13F8303C 		ldrb	r3, [r3, #-48]	@ zero_extendqisi2
 3120              		.loc 1 812 52
 3121 0304 3B3B     		subs	r3, r3, #59
 3122              		.loc 1 812 77
 3123 0306 FA7A     		ldrb	r2, [r7, #11]	@ zero_extendqisi2
ARM GAS  /tmp/ccBaawNW.s 			page 71


 3124 0308 5208     		lsrs	r2, r2, #1
 3125 030a D2B2     		uxtb	r2, r2
 3126              		.loc 1 812 64
 3127 030c 9A1A     		subs	r2, r3, r2
 3128              		.loc 1 812 30
 3129 030e 7B68     		ldr	r3, [r7, #4]
 3130 0310 1A60     		str	r2, [r3]
 813:hardware/src/grey.c **** 				return GETMIDLOC;
 3131              		.loc 1 813 12
 3132 0312 1823     		movs	r3, #24
 3133 0314 22E0     		b	.L160
 3134              	.L158:
 814:hardware/src/grey.c **** 			}
 815:hardware/src/grey.c **** 			else
 816:hardware/src/grey.c **** 			{
 817:hardware/src/grey.c **** 				*realVerticalDevationLoc = (lineWidth / 2) - rightMaxULineLoc[i] + MIDHORLOC;
 3135              		.loc 1 817 43
 3136 0316 FB7A     		ldrb	r3, [r7, #11]	@ zero_extendqisi2
 3137 0318 5B08     		lsrs	r3, r3, #1
 3138 031a DBB2     		uxtb	r3, r3
 3139 031c 1A46     		mov	r2, r3
 3140              		.loc 1 817 66
 3141 031e 97F86730 		ldrb	r3, [r7, #103]	@ zero_extendqisi2
 3142 0322 07F16801 		add	r1, r7, #104
 3143 0326 0B44     		add	r3, r3, r1
 3144 0328 13F8303C 		ldrb	r3, [r3, #-48]	@ zero_extendqisi2
 3145              		.loc 1 817 48
 3146 032c D31A     		subs	r3, r2, r3
 3147              		.loc 1 817 70
 3148 032e 03F13B02 		add	r2, r3, #59
 3149              		.loc 1 817 30
 3150 0332 7B68     		ldr	r3, [r7, #4]
 3151 0334 1A60     		str	r2, [r3]
 818:hardware/src/grey.c **** 				*realVerticalDevationLoc = 0 - *realVerticalDevationLoc;
 3152              		.loc 1 818 36
 3153 0336 7B68     		ldr	r3, [r7, #4]
 3154 0338 1B68     		ldr	r3, [r3]
 3155              		.loc 1 818 34
 3156 033a 5A42     		rsbs	r2, r3, #0
 3157              		.loc 1 818 30
 3158 033c 7B68     		ldr	r3, [r7, #4]
 3159 033e 1A60     		str	r2, [r3]
 819:hardware/src/grey.c **** 				return GETMIDLOC;
 3160              		.loc 1 819 12
 3161 0340 1823     		movs	r3, #24
 3162 0342 0BE0     		b	.L160
 3163              	.L157:
 803:hardware/src/grey.c **** 	{
 3164              		.loc 1 803 31 discriminator 2
 3165 0344 97F86730 		ldrb	r3, [r7, #103]	@ zero_extendqisi2
 3166 0348 0133     		adds	r3, r3, #1
 3167 034a 87F86730 		strb	r3, [r7, #103]
 3168              	.L156:
 803:hardware/src/grey.c **** 	{
 3169              		.loc 1 803 14 discriminator 1
 3170 034e 97F83630 		ldrb	r3, [r7, #54]	@ zero_extendqisi2
 803:hardware/src/grey.c **** 	{
ARM GAS  /tmp/ccBaawNW.s 			page 72


 3171              		.loc 1 803 2 discriminator 1
 3172 0352 97F86720 		ldrb	r2, [r7, #103]	@ zero_extendqisi2
 3173 0356 9A42     		cmp	r2, r3
 3174 0358 B4D3     		bcc	.L159
 820:hardware/src/grey.c **** 			}
 821:hardware/src/grey.c **** 		}
 822:hardware/src/grey.c **** 	}
 823:hardware/src/grey.c **** /* 左下角、右下角优化方法  */
 824:hardware/src/grey.c **** 	// left_nums = 0;
 825:hardware/src/grey.c **** 	// right_nums = 0;
 826:hardware/src/grey.c **** 	// getOneSideUsefulLine(leftBlackLoc,countLeftZero,leftMaxULineLoc,&leftMaxULen,leftMaxUBlackHeigh
 827:hardware/src/grey.c **** 	// getOneSideUsefulLine(rightBlackLoc,countRightZero,rightMaxULineLoc,&rightMaxULen,rightMaxUBlack
 828:hardware/src/grey.c **** 	// if(leftMaxUBlackHeight[leftMaxULen] < )     //the lowest point
 829:hardware/src/grey.c **** 	// for(i=0;i<leftMaxULen;i++){
 830:hardware/src/grey.c **** 	// 	if(leftMaxULineLoc[i] < NEEDWITH/2){
 831:hardware/src/grey.c **** 	// 		left_nums++;
 832:hardware/src/grey.c **** 	// 	}
 833:hardware/src/grey.c **** 	// }
 834:hardware/src/grey.c **** 	// for(i=0;i<rightMaxULen;i++){
 835:hardware/src/grey.c **** 	// 	if(rightMaxULineLoc[i] > NEEDWITH/2){
 836:hardware/src/grey.c **** 	// 		right_nums++;
 837:hardware/src/grey.c **** 	// 	}
 838:hardware/src/grey.c **** 	// }
 839:hardware/src/grey.c **** 	// if(left_nums >= leftMaxULen*2/3){
 840:hardware/src/grey.c **** 	// 	*realVerticalDevationLoc = -NEEDWITH/2;
 841:hardware/src/grey.c **** 	// }
 842:hardware/src/grey.c **** 	// else if(right_nums >= rightMaxULen*2/3){
 843:hardware/src/grey.c **** 	// 	*realVerticalDevationLoc = NEEDWITH/2;
 844:hardware/src/grey.c **** 	// }
 845:hardware/src/grey.c **** 	return NOMIDLOC;
 3175              		.loc 1 845 9
 3176 035a 1923     		movs	r3, #25
 3177              	.L160:
 846:hardware/src/grey.c **** }
 3178              		.loc 1 846 1 discriminator 1
 3179 035c 1846     		mov	r0, r3
 3180 035e 6C37     		adds	r7, r7, #108
 3181              	.LCFI49:
 3182              		.cfi_def_cfa_offset 12
 3183 0360 BD46     		mov	sp, r7
 3184              	.LCFI50:
 3185              		.cfi_def_cfa_register 13
 3186              		@ sp needed
 3187 0362 90BD     		pop	{r4, r7, pc}
 3188              	.L162:
 3189              		.align	2
 3190              	.L161:
 3191 0364 00000000 		.word	leftBlackLoc
 3192 0368 00000000 		.word	rightBlackLoc
 3193              		.cfi_endproc
 3194              	.LFE73:
 3196              		.global	__aeabi_i2d
 3197              		.global	__aeabi_dadd
 3198              		.global	__aeabi_ddiv
 3199              		.global	__aeabi_dsub
 3200              		.global	__aeabi_dcmpeq
 3201              		.global	__aeabi_dcmpge
ARM GAS  /tmp/ccBaawNW.s 			page 73


 3202              		.global	__aeabi_dcmple
 3203              		.section	.text.regression,"ax",%progbits
 3204              		.align	1
 3205              		.global	regression
 3206              		.syntax unified
 3207              		.thumb
 3208              		.thumb_func
 3209              		.fpu softvfp
 3211              	regression:
 3212              	.LFB74:
 847:hardware/src/grey.c **** 
 848:hardware/src/grey.c **** int regression(u8 *maxLine,u8 *maxLineH,u8 *maxLen,double *oK,int *ob)
 849:hardware/src/grey.c **** {
 3213              		.loc 1 849 1
 3214              		.cfi_startproc
 3215              		@ args = 4, pretend = 0, frame = 88
 3216              		@ frame_needed = 1, uses_anonymous_args = 0
 3217 0000 2DE9B043 		push	{r4, r5, r7, r8, r9, lr}
 3218              	.LCFI51:
 3219              		.cfi_def_cfa_offset 24
 3220              		.cfi_offset 4, -24
 3221              		.cfi_offset 5, -20
 3222              		.cfi_offset 7, -16
 3223              		.cfi_offset 8, -12
 3224              		.cfi_offset 9, -8
 3225              		.cfi_offset 14, -4
 3226 0004 96B0     		sub	sp, sp, #88
 3227              	.LCFI52:
 3228              		.cfi_def_cfa_offset 112
 3229 0006 00AF     		add	r7, sp, #0
 3230              	.LCFI53:
 3231              		.cfi_def_cfa_register 7
 3232 0008 F860     		str	r0, [r7, #12]
 3233 000a B960     		str	r1, [r7, #8]
 3234 000c 7A60     		str	r2, [r7, #4]
 3235 000e 3B60     		str	r3, [r7]
 850:hardware/src/grey.c **** 	  /*累积变量*/
 851:hardware/src/grey.c **** 	  double x_sum = 0,y_sum = 0,xy_sum = 0,xx_sum = 0;
 3236              		.loc 1 851 11
 3237 0010 4FF00002 		mov	r2, #0
 3238 0014 4FF00003 		mov	r3, #0
 3239 0018 C7E91423 		strd	r2, [r7, #80]
 3240              		.loc 1 851 21
 3241 001c 4FF00002 		mov	r2, #0
 3242 0020 4FF00003 		mov	r3, #0
 3243 0024 C7E91223 		strd	r2, [r7, #72]
 3244              		.loc 1 851 31
 3245 0028 4FF00002 		mov	r2, #0
 3246 002c 4FF00003 		mov	r3, #0
 3247 0030 C7E91023 		strd	r2, [r7, #64]
 3248              		.loc 1 851 42
 3249 0034 4FF00002 		mov	r2, #0
 3250 0038 4FF00003 		mov	r3, #0
 3251 003c C7E90E23 		strd	r2, [r7, #56]
 852:hardware/src/grey.c **** 		double x_avr = 0,y_avr = 0,xy_avr = 0,xx_avr = 0;
 3252              		.loc 1 852 10
 3253 0040 4FF00002 		mov	r2, #0
ARM GAS  /tmp/ccBaawNW.s 			page 74


 3254 0044 4FF00003 		mov	r3, #0
 3255 0048 C7E90A23 		strd	r2, [r7, #40]
 3256              		.loc 1 852 20
 3257 004c 4FF00002 		mov	r2, #0
 3258 0050 4FF00003 		mov	r3, #0
 3259 0054 C7E90823 		strd	r2, [r7, #32]
 3260              		.loc 1 852 30
 3261 0058 4FF00002 		mov	r2, #0
 3262 005c 4FF00003 		mov	r3, #0
 3263 0060 C7E90623 		strd	r2, [r7, #24]
 3264              		.loc 1 852 41
 3265 0064 4FF00002 		mov	r2, #0
 3266 0068 4FF00003 		mov	r3, #0
 3267 006c C7E90423 		strd	r2, [r7, #16]
 853:hardware/src/grey.c **** 		int i;
 854:hardware/src/grey.c **** 		x_sum=0;y_sum=0;xy_sum=0;xx_sum=0;
 3268              		.loc 1 854 8
 3269 0070 4FF00002 		mov	r2, #0
 3270 0074 4FF00003 		mov	r3, #0
 3271 0078 C7E91423 		strd	r2, [r7, #80]
 3272              		.loc 1 854 16
 3273 007c 4FF00002 		mov	r2, #0
 3274 0080 4FF00003 		mov	r3, #0
 3275 0084 C7E91223 		strd	r2, [r7, #72]
 3276              		.loc 1 854 25
 3277 0088 4FF00002 		mov	r2, #0
 3278 008c 4FF00003 		mov	r3, #0
 3279 0090 C7E91023 		strd	r2, [r7, #64]
 3280              		.loc 1 854 34
 3281 0094 4FF00002 		mov	r2, #0
 3282 0098 4FF00003 		mov	r3, #0
 3283 009c C7E90E23 		strd	r2, [r7, #56]
 855:hardware/src/grey.c **** 		for(i=0;i < *maxLen;i++)
 3284              		.loc 1 855 8
 3285 00a0 0023     		movs	r3, #0
 3286 00a2 7B63     		str	r3, [r7, #52]
 3287              		.loc 1 855 3
 3288 00a4 58E0     		b	.L164
 3289              	.L165:
 856:hardware/src/grey.c **** 		{
 857:hardware/src/grey.c **** 				x_sum+=maxLine[i];
 3290              		.loc 1 857 19 discriminator 3
 3291 00a6 7B6B     		ldr	r3, [r7, #52]
 3292 00a8 FA68     		ldr	r2, [r7, #12]
 3293 00aa 1344     		add	r3, r3, r2
 3294 00ac 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 3295              		.loc 1 857 10 discriminator 3
 3296 00ae 1846     		mov	r0, r3
 3297 00b0 FFF7FEFF 		bl	__aeabi_i2d
 3298 00b4 0246     		mov	r2, r0
 3299 00b6 0B46     		mov	r3, r1
 3300 00b8 D7E91401 		ldrd	r0, [r7, #80]
 3301 00bc FFF7FEFF 		bl	__aeabi_dadd
 3302 00c0 0246     		mov	r2, r0
 3303 00c2 0B46     		mov	r3, r1
 3304 00c4 C7E91423 		strd	r2, [r7, #80]
 858:hardware/src/grey.c **** 				// y_sum+= i;
ARM GAS  /tmp/ccBaawNW.s 			page 75


 859:hardware/src/grey.c **** 				y_sum+= (NEEDHEIGHT - maxLineH[i]);
 3305              		.loc 1 859 35 discriminator 3
 3306 00c8 7B6B     		ldr	r3, [r7, #52]
 3307 00ca BA68     		ldr	r2, [r7, #8]
 3308 00cc 1344     		add	r3, r3, r2
 3309 00ce 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 3310              		.loc 1 859 25 discriminator 3
 3311 00d0 C3F15003 		rsb	r3, r3, #80
 3312              		.loc 1 859 10 discriminator 3
 3313 00d4 1846     		mov	r0, r3
 3314 00d6 FFF7FEFF 		bl	__aeabi_i2d
 3315 00da 0246     		mov	r2, r0
 3316 00dc 0B46     		mov	r3, r1
 3317 00de D7E91201 		ldrd	r0, [r7, #72]
 3318 00e2 FFF7FEFF 		bl	__aeabi_dadd
 3319 00e6 0246     		mov	r2, r0
 3320 00e8 0B46     		mov	r3, r1
 3321 00ea C7E91223 		strd	r2, [r7, #72]
 860:hardware/src/grey.c **** 				// xy_sum+=maxLine[i]*(i);
 861:hardware/src/grey.c **** 				xy_sum+=maxLine[i]*(NEEDHEIGHT-maxLineH[i]);
 3322              		.loc 1 861 20 discriminator 3
 3323 00ee 7B6B     		ldr	r3, [r7, #52]
 3324 00f0 FA68     		ldr	r2, [r7, #12]
 3325 00f2 1344     		add	r3, r3, r2
 3326 00f4 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 3327 00f6 1946     		mov	r1, r3
 3328              		.loc 1 861 44 discriminator 3
 3329 00f8 7B6B     		ldr	r3, [r7, #52]
 3330 00fa BA68     		ldr	r2, [r7, #8]
 3331 00fc 1344     		add	r3, r3, r2
 3332 00fe 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 3333              		.loc 1 861 35 discriminator 3
 3334 0100 C3F15003 		rsb	r3, r3, #80
 3335              		.loc 1 861 23 discriminator 3
 3336 0104 01FB03F3 		mul	r3, r1, r3
 3337              		.loc 1 861 11 discriminator 3
 3338 0108 1846     		mov	r0, r3
 3339 010a FFF7FEFF 		bl	__aeabi_i2d
 3340 010e 0246     		mov	r2, r0
 3341 0110 0B46     		mov	r3, r1
 3342 0112 D7E91001 		ldrd	r0, [r7, #64]
 3343 0116 FFF7FEFF 		bl	__aeabi_dadd
 3344 011a 0246     		mov	r2, r0
 3345 011c 0B46     		mov	r3, r1
 3346 011e C7E91023 		strd	r2, [r7, #64]
 862:hardware/src/grey.c **** 				xx_sum+=maxLine[i]*maxLine[i];
 3347              		.loc 1 862 20 discriminator 3
 3348 0122 7B6B     		ldr	r3, [r7, #52]
 3349 0124 FA68     		ldr	r2, [r7, #12]
 3350 0126 1344     		add	r3, r3, r2
 3351 0128 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 3352 012a 1946     		mov	r1, r3
 3353              		.loc 1 862 31 discriminator 3
 3354 012c 7B6B     		ldr	r3, [r7, #52]
 3355 012e FA68     		ldr	r2, [r7, #12]
 3356 0130 1344     		add	r3, r3, r2
 3357 0132 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
ARM GAS  /tmp/ccBaawNW.s 			page 76


 3358              		.loc 1 862 23 discriminator 3
 3359 0134 01FB03F3 		mul	r3, r1, r3
 3360              		.loc 1 862 11 discriminator 3
 3361 0138 1846     		mov	r0, r3
 3362 013a FFF7FEFF 		bl	__aeabi_i2d
 3363 013e 0246     		mov	r2, r0
 3364 0140 0B46     		mov	r3, r1
 3365 0142 D7E90E01 		ldrd	r0, [r7, #56]
 3366 0146 FFF7FEFF 		bl	__aeabi_dadd
 3367 014a 0246     		mov	r2, r0
 3368 014c 0B46     		mov	r3, r1
 3369 014e C7E90E23 		strd	r2, [r7, #56]
 855:hardware/src/grey.c **** 		{
 3370              		.loc 1 855 24 discriminator 3
 3371 0152 7B6B     		ldr	r3, [r7, #52]
 3372 0154 0133     		adds	r3, r3, #1
 3373 0156 7B63     		str	r3, [r7, #52]
 3374              	.L164:
 855:hardware/src/grey.c **** 		{
 3375              		.loc 1 855 15 discriminator 1
 3376 0158 7B68     		ldr	r3, [r7, #4]
 3377 015a 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 3378 015c 1A46     		mov	r2, r3
 855:hardware/src/grey.c **** 		{
 3379              		.loc 1 855 3 discriminator 1
 3380 015e 7B6B     		ldr	r3, [r7, #52]
 3381 0160 9342     		cmp	r3, r2
 3382 0162 A0DB     		blt	.L165
 863:hardware/src/grey.c **** 		}
 864:hardware/src/grey.c **** 		x_avr=x_sum/(*maxLen);
 3383              		.loc 1 864 16
 3384 0164 7B68     		ldr	r3, [r7, #4]
 3385 0166 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 3386              		.loc 1 864 14
 3387 0168 1846     		mov	r0, r3
 3388 016a FFF7FEFF 		bl	__aeabi_i2d
 3389 016e 0246     		mov	r2, r0
 3390 0170 0B46     		mov	r3, r1
 3391              		.loc 1 864 8
 3392 0172 D7E91401 		ldrd	r0, [r7, #80]
 3393 0176 FFF7FEFF 		bl	__aeabi_ddiv
 3394 017a 0246     		mov	r2, r0
 3395 017c 0B46     		mov	r3, r1
 3396 017e C7E90A23 		strd	r2, [r7, #40]
 865:hardware/src/grey.c **** 		y_avr=y_sum/(*maxLen);
 3397              		.loc 1 865 16
 3398 0182 7B68     		ldr	r3, [r7, #4]
 3399 0184 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 3400              		.loc 1 865 14
 3401 0186 1846     		mov	r0, r3
 3402 0188 FFF7FEFF 		bl	__aeabi_i2d
 3403 018c 0246     		mov	r2, r0
 3404 018e 0B46     		mov	r3, r1
 3405              		.loc 1 865 8
 3406 0190 D7E91201 		ldrd	r0, [r7, #72]
 3407 0194 FFF7FEFF 		bl	__aeabi_ddiv
 3408 0198 0246     		mov	r2, r0
ARM GAS  /tmp/ccBaawNW.s 			page 77


 3409 019a 0B46     		mov	r3, r1
 3410 019c C7E90823 		strd	r2, [r7, #32]
 866:hardware/src/grey.c **** 		xy_avr=xy_sum/(*maxLen);
 3411              		.loc 1 866 18
 3412 01a0 7B68     		ldr	r3, [r7, #4]
 3413 01a2 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 3414              		.loc 1 866 16
 3415 01a4 1846     		mov	r0, r3
 3416 01a6 FFF7FEFF 		bl	__aeabi_i2d
 3417 01aa 0246     		mov	r2, r0
 3418 01ac 0B46     		mov	r3, r1
 3419              		.loc 1 866 9
 3420 01ae D7E91001 		ldrd	r0, [r7, #64]
 3421 01b2 FFF7FEFF 		bl	__aeabi_ddiv
 3422 01b6 0246     		mov	r2, r0
 3423 01b8 0B46     		mov	r3, r1
 3424 01ba C7E90623 		strd	r2, [r7, #24]
 867:hardware/src/grey.c **** 		xx_avr=xx_sum/(*maxLen);
 3425              		.loc 1 867 18
 3426 01be 7B68     		ldr	r3, [r7, #4]
 3427 01c0 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 3428              		.loc 1 867 16
 3429 01c2 1846     		mov	r0, r3
 3430 01c4 FFF7FEFF 		bl	__aeabi_i2d
 3431 01c8 0246     		mov	r2, r0
 3432 01ca 0B46     		mov	r3, r1
 3433              		.loc 1 867 9
 3434 01cc D7E90E01 		ldrd	r0, [r7, #56]
 3435 01d0 FFF7FEFF 		bl	__aeabi_ddiv
 3436 01d4 0246     		mov	r2, r0
 3437 01d6 0B46     		mov	r3, r1
 3438 01d8 C7E90423 		strd	r2, [r7, #16]
 868:hardware/src/grey.c **** 		
 869:hardware/src/grey.c **** 		/*公式中分子为0*/
 870:hardware/src/grey.c **** 		if((xy_avr-x_avr*y_avr)==0)
 3439              		.loc 1 870 19
 3440 01dc D7E90823 		ldrd	r2, [r7, #32]
 3441 01e0 D7E90A01 		ldrd	r0, [r7, #40]
 3442 01e4 FFF7FEFF 		bl	__aeabi_dmul
 3443 01e8 0246     		mov	r2, r0
 3444 01ea 0B46     		mov	r3, r1
 3445              		.loc 1 870 13
 3446 01ec D7E90601 		ldrd	r0, [r7, #24]
 3447 01f0 FFF7FEFF 		bl	__aeabi_dsub
 3448 01f4 0246     		mov	r2, r0
 3449 01f6 0B46     		mov	r3, r1
 3450 01f8 1046     		mov	r0, r2
 3451 01fa 1946     		mov	r1, r3
 3452              		.loc 1 870 5
 3453 01fc 4FF00002 		mov	r2, #0
 3454 0200 4FF00003 		mov	r3, #0
 3455 0204 FFF7FEFF 		bl	__aeabi_dcmpeq
 3456 0208 0346     		mov	r3, r0
 3457 020a 002B     		cmp	r3, #0
 3458 020c 08D0     		beq	.L173
 871:hardware/src/grey.c **** 		{			  
 872:hardware/src/grey.c **** 			  *oK = 0;
ARM GAS  /tmp/ccBaawNW.s 			page 78


 3459              		.loc 1 872 10
 3460 020e 3968     		ldr	r1, [r7]
 3461 0210 4FF00002 		mov	r2, #0
 3462 0214 4FF00003 		mov	r3, #0
 3463 0218 C1E90023 		strd	r2, [r1]
 873:hardware/src/grey.c **** 			  /*用完清除无用的最长有效段，以便下一次采集*/
 874:hardware/src/grey.c **** 			//   *maxLen = 0;
 875:hardware/src/grey.c **** 	    //   memset(maxLine,0,(NEEDHEIGHT)/(SKIPLINE));	  
 876:hardware/src/grey.c **** 				return NOSLOPE;
 3464              		.loc 1 876 12
 3465 021c 0B23     		movs	r3, #11
 3466 021e 73E0     		b	.L168
 3467              	.L173:
 877:hardware/src/grey.c **** 		}
 878:hardware/src/grey.c **** 		else
 879:hardware/src/grey.c **** 		{
 880:hardware/src/grey.c **** 				*oK = (xx_avr-x_avr*x_avr)/(xy_avr-x_avr*y_avr);//反斜率
 3468              		.loc 1 880 24
 3469 0220 D7E90A23 		ldrd	r2, [r7, #40]
 3470 0224 D7E90A01 		ldrd	r0, [r7, #40]
 3471 0228 FFF7FEFF 		bl	__aeabi_dmul
 3472 022c 0246     		mov	r2, r0
 3473 022e 0B46     		mov	r3, r1
 3474              		.loc 1 880 18
 3475 0230 D7E90401 		ldrd	r0, [r7, #16]
 3476 0234 FFF7FEFF 		bl	__aeabi_dsub
 3477 0238 0246     		mov	r2, r0
 3478 023a 0B46     		mov	r3, r1
 3479 023c 1446     		mov	r4, r2
 3480 023e 1D46     		mov	r5, r3
 3481              		.loc 1 880 45
 3482 0240 D7E90823 		ldrd	r2, [r7, #32]
 3483 0244 D7E90A01 		ldrd	r0, [r7, #40]
 3484 0248 FFF7FEFF 		bl	__aeabi_dmul
 3485 024c 0246     		mov	r2, r0
 3486 024e 0B46     		mov	r3, r1
 3487              		.loc 1 880 39
 3488 0250 D7E90601 		ldrd	r0, [r7, #24]
 3489 0254 FFF7FEFF 		bl	__aeabi_dsub
 3490 0258 0246     		mov	r2, r0
 3491 025a 0B46     		mov	r3, r1
 3492              		.loc 1 880 31
 3493 025c 2046     		mov	r0, r4
 3494 025e 2946     		mov	r1, r5
 3495 0260 FFF7FEFF 		bl	__aeabi_ddiv
 3496 0264 0246     		mov	r2, r0
 3497 0266 0B46     		mov	r3, r1
 3498              		.loc 1 880 9
 3499 0268 3968     		ldr	r1, [r7]
 3500 026a C1E90023 		strd	r2, [r1]
 881:hardware/src/grey.c **** 				// *oK = (xy_avr-x_avr*y_avr)/(xx_avr-x_avr*x_avr);//正斜率
 882:hardware/src/grey.c **** 				// *oK = 0 - (*oK);
 883:hardware/src/grey.c **** //				realK=(xy_avr-x_avr*y_avr)/(xx_avr-x_avr*x_avr);//正斜率
 884:hardware/src/grey.c **** 				// *ob = maxLine[0];//获取K
 885:hardware/src/grey.c **** 				*ob = 80 - maxLineH[0]-(1/(*oK))*(maxLine[0]);//获取K
 3501              		.loc 1 885 24
 3502 026e BB68     		ldr	r3, [r7, #8]
ARM GAS  /tmp/ccBaawNW.s 			page 79


 3503 0270 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 3504              		.loc 1 885 14
 3505 0272 C3F15003 		rsb	r3, r3, #80
 3506              		.loc 1 885 27
 3507 0276 1846     		mov	r0, r3
 3508 0278 FFF7FEFF 		bl	__aeabi_i2d
 3509 027c 0446     		mov	r4, r0
 3510 027e 0D46     		mov	r5, r1
 3511              		.loc 1 885 32
 3512 0280 3B68     		ldr	r3, [r7]
 3513 0282 D3E90023 		ldrd	r2, [r3]
 3514              		.loc 1 885 30
 3515 0286 4FF00000 		mov	r0, #0
 3516 028a 2249     		ldr	r1, .L174
 3517 028c FFF7FEFF 		bl	__aeabi_ddiv
 3518 0290 0246     		mov	r2, r0
 3519 0292 0B46     		mov	r3, r1
 3520 0294 9046     		mov	r8, r2
 3521 0296 9946     		mov	r9, r3
 3522              		.loc 1 885 46
 3523 0298 FB68     		ldr	r3, [r7, #12]
 3524 029a 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 3525              		.loc 1 885 37
 3526 029c 1846     		mov	r0, r3
 3527 029e FFF7FEFF 		bl	__aeabi_i2d
 3528 02a2 0246     		mov	r2, r0
 3529 02a4 0B46     		mov	r3, r1
 3530 02a6 4046     		mov	r0, r8
 3531 02a8 4946     		mov	r1, r9
 3532 02aa FFF7FEFF 		bl	__aeabi_dmul
 3533 02ae 0246     		mov	r2, r0
 3534 02b0 0B46     		mov	r3, r1
 3535              		.loc 1 885 27
 3536 02b2 2046     		mov	r0, r4
 3537 02b4 2946     		mov	r1, r5
 3538 02b6 FFF7FEFF 		bl	__aeabi_dsub
 3539 02ba 0246     		mov	r2, r0
 3540 02bc 0B46     		mov	r3, r1
 3541              		.loc 1 885 9
 3542 02be 1046     		mov	r0, r2
 3543 02c0 1946     		mov	r1, r3
 3544 02c2 FFF7FEFF 		bl	__aeabi_d2iz
 3545 02c6 0246     		mov	r2, r0
 3546 02c8 3B6F     		ldr	r3, [r7, #112]
 3547 02ca 1A60     		str	r2, [r3]
 886:hardware/src/grey.c **** 			
 887:hardware/src/grey.c **** 			   //滤除无用斜率
 888:hardware/src/grey.c **** 			  if(((*oK) >= 20) || ((*oK) <= -20))
 3548              		.loc 1 888 11
 3549 02cc 3B68     		ldr	r3, [r7]
 3550 02ce D3E90001 		ldrd	r0, [r3]
 3551              		.loc 1 888 8
 3552 02d2 4FF00002 		mov	r2, #0
 3553 02d6 104B     		ldr	r3, .L174+4
 3554 02d8 FFF7FEFF 		bl	__aeabi_dcmpge
 3555 02dc 0346     		mov	r3, r0
 3556 02de 002B     		cmp	r3, #0
ARM GAS  /tmp/ccBaawNW.s 			page 80


 3557 02e0 0AD1     		bne	.L169
 3558              		.loc 1 888 28 discriminator 1
 3559 02e2 3B68     		ldr	r3, [r7]
 3560 02e4 D3E90001 		ldrd	r0, [r3]
 3561              		.loc 1 888 23 discriminator 1
 3562 02e8 4FF00002 		mov	r2, #0
 3563 02ec 0B4B     		ldr	r3, .L174+8
 3564 02ee FFF7FEFF 		bl	__aeabi_dcmple
 3565 02f2 0346     		mov	r3, r0
 3566 02f4 002B     		cmp	r3, #0
 3567 02f6 06D0     		beq	.L170
 3568              	.L169:
 889:hardware/src/grey.c **** 				{
 890:hardware/src/grey.c **** 						(*oK) = 0;
 3569              		.loc 1 890 13
 3570 02f8 3968     		ldr	r1, [r7]
 3571 02fa 4FF00002 		mov	r2, #0
 3572 02fe 4FF00003 		mov	r3, #0
 3573 0302 C1E90023 		strd	r2, [r1]
 3574              	.L170:
 891:hardware/src/grey.c **** 				}
 892:hardware/src/grey.c **** 			
 893:hardware/src/grey.c ****         /*用完清除无用的最长有效段，以便下一次采集*/
 894:hardware/src/grey.c **** 			//   *maxLen = 0;
 895:hardware/src/grey.c **** 	    //   memset(maxLine,0,(NEEDHEIGHT)/(SKIPLINE));		
 896:hardware/src/grey.c **** 			  
 897:hardware/src/grey.c **** 				return GOTSLOPE;
 3575              		.loc 1 897 12
 3576 0306 0C23     		movs	r3, #12
 3577              	.L168:
 898:hardware/src/grey.c **** 		}
 899:hardware/src/grey.c **** }
 3578              		.loc 1 899 1
 3579 0308 1846     		mov	r0, r3
 3580 030a 5837     		adds	r7, r7, #88
 3581              	.LCFI54:
 3582              		.cfi_def_cfa_offset 24
 3583 030c BD46     		mov	sp, r7
 3584              	.LCFI55:
 3585              		.cfi_def_cfa_register 13
 3586              		@ sp needed
 3587 030e BDE8B083 		pop	{r4, r5, r7, r8, r9, pc}
 3588              	.L175:
 3589 0312 00BF     		.align	2
 3590              	.L174:
 3591 0314 0000F03F 		.word	1072693248
 3592 0318 00003440 		.word	1077149696
 3593 031c 000034C0 		.word	-1070333952
 3594              		.cfi_endproc
 3595              	.LFE74:
 3597              		.section	.bss.line2stop.1,"aw",%nobits
 3600              	line2stop.1:
 3601 0000 00       		.space	1
 3602              		.section	.bss.slope2stop.0,"aw",%nobits
 3605              	slope2stop.0:
 3606 0000 00       		.space	1
 3607              		.text
ARM GAS  /tmp/ccBaawNW.s 			page 81


 3608              	.Letext0:
 3609              		.file 2 "/home/ubuntu/tools/gcc-arm-none-eabi-10-2020-q4-major/arm-none-eabi/include/machine/_defa
 3610              		.file 3 "/home/ubuntu/tools/gcc-arm-none-eabi-10-2020-q4-major/arm-none-eabi/include/sys/_stdint.h
 3611              		.file 4 "Inc/stm32f10x.h"
 3612              		.file 5 "hardware/inc/lcd.h"
 3613              		.file 6 "<built-in>"
 3614              		.file 7 "hardware/inc/AllHead.h"
ARM GAS  /tmp/ccBaawNW.s 			page 82


DEFINED SYMBOLS
                            *ABS*:0000000000000000 grey.c
     /tmp/ccBaawNW.s:19     .data.MidGreyVal:0000000000000000 MidGreyVal
     /tmp/ccBaawNW.s:26     .bss.cutImg:0000000000000000 cutImg
     /tmp/ccBaawNW.s:23     .bss.cutImg:0000000000000000 $d
     /tmp/ccBaawNW.s:33     .bss.leftBlackLoc:0000000000000000 leftBlackLoc
     /tmp/ccBaawNW.s:30     .bss.leftBlackLoc:0000000000000000 $d
     /tmp/ccBaawNW.s:40     .bss.rightBlackLoc:0000000000000000 rightBlackLoc
     /tmp/ccBaawNW.s:37     .bss.rightBlackLoc:0000000000000000 $d
     /tmp/ccBaawNW.s:47     .bss.maxUsefulBlackLine:0000000000000000 maxUsefulBlackLine
     /tmp/ccBaawNW.s:44     .bss.maxUsefulBlackLine:0000000000000000 $d
     /tmp/ccBaawNW.s:53     .bss.maxUsefulLineLen:0000000000000000 maxUsefulLineLen
     /tmp/ccBaawNW.s:54     .bss.maxUsefulLineLen:0000000000000000 $d
     /tmp/ccBaawNW.s:60     .bss.maxUsefulBlackHeight:0000000000000000 maxUsefulBlackHeight
     /tmp/ccBaawNW.s:57     .bss.maxUsefulBlackHeight:0000000000000000 $d
     /tmp/ccBaawNW.s:67     .bss.overK:0000000000000000 overK
     /tmp/ccBaawNW.s:64     .bss.overK:0000000000000000 $d
     /tmp/ccBaawNW.s:74     .bss.b:0000000000000000 b
     /tmp/ccBaawNW.s:71     .bss.b:0000000000000000 $d
     /tmp/ccBaawNW.s:81     .bss.lineDeviationLoc:0000000000000000 lineDeviationLoc
     /tmp/ccBaawNW.s:78     .bss.lineDeviationLoc:0000000000000000 $d
     /tmp/ccBaawNW.s:87     .bss.FLAG_BORDER:0000000000000000 FLAG_BORDER
     /tmp/ccBaawNW.s:88     .bss.FLAG_BORDER:0000000000000000 $d
     /tmp/ccBaawNW.s:93     .bss.devLocRes:0000000000000000 devLocRes
     /tmp/ccBaawNW.s:94     .bss.devLocRes:0000000000000000 $d
     /tmp/ccBaawNW.s:96     .text.cameraOperation:0000000000000000 $t
     /tmp/ccBaawNW.s:104    .text.cameraOperation:0000000000000000 cameraOperation
     /tmp/ccBaawNW.s:973    .text.camera_refresh:0000000000000000 camera_refresh
     /tmp/ccBaawNW.s:1403   .text.getLineEdge:0000000000000000 getLineEdge
     /tmp/ccBaawNW.s:2184   .text.getUsefulLine:0000000000000000 getUsefulLine
     /tmp/ccBaawNW.s:3211   .text.regression:0000000000000000 regression
     /tmp/ccBaawNW.s:306    .text.getCmdByDeviLoc:0000000000000000 getCmdByDeviLoc
     /tmp/ccBaawNW.s:597    .text.memsetBothBlackLoc:0000000000000000 memsetBothBlackLoc
     /tmp/ccBaawNW.s:266    .text.cameraOperation:00000000000000e4 $d
     /tmp/ccBaawNW.s:3600   .bss.line2stop.1:0000000000000000 line2stop.1
     /tmp/ccBaawNW.s:3605   .bss.slope2stop.0:0000000000000000 slope2stop.0
     /tmp/ccBaawNW.s:280    .rodata:0000000000000000 $d
     /tmp/ccBaawNW.s:299    .text.getCmdByDeviLoc:0000000000000000 $t
     /tmp/ccBaawNW.s:2682   .text.getLineLocCompare2MidLine:0000000000000000 getLineLocCompare2MidLine
     /tmp/ccBaawNW.s:338    .text.getCmdByDeviLoc:0000000000000024 $d
     /tmp/ccBaawNW.s:366    .text.getCmdByDeviLoc:0000000000000094 $t
     /tmp/ccBaawNW.s:578    .text.getCmdByDeviLoc:00000000000001a0 $d
     /tmp/ccBaawNW.s:590    .text.memsetBothBlackLoc:0000000000000000 $t
     /tmp/ccBaawNW.s:627    .text.memsetBothBlackLoc:000000000000001c $d
     /tmp/ccBaawNW.s:633    .text.cameraRefresh:0000000000000000 $t
     /tmp/ccBaawNW.s:640    .text.cameraRefresh:0000000000000000 cameraRefresh
     /tmp/ccBaawNW.s:954    .text.cameraRefresh:00000000000001b0 $d
     /tmp/ccBaawNW.s:966    .text.camera_refresh:0000000000000000 $t
     /tmp/ccBaawNW.s:1259   .text.camera_refresh:000000000000018c $d
     /tmp/ccBaawNW.s:1282   .text.printToUart:0000000000000000 $t
     /tmp/ccBaawNW.s:1289   .text.printToUart:0000000000000000 printToUart
     /tmp/ccBaawNW.s:1383   .text.printToUart:000000000000007c $d
     /tmp/ccBaawNW.s:1396   .text.getLineEdge:0000000000000000 $t
     /tmp/ccBaawNW.s:1762   .text.getLineEdge:0000000000000200 $d
     /tmp/ccBaawNW.s:1768   .text.getOneSideUsefulLine:0000000000000000 $t
     /tmp/ccBaawNW.s:1775   .text.getOneSideUsefulLine:0000000000000000 getOneSideUsefulLine
     /tmp/ccBaawNW.s:2177   .text.getUsefulLine:0000000000000000 $t
ARM GAS  /tmp/ccBaawNW.s 			page 83


     /tmp/ccBaawNW.s:2428   .text.getUsefulLine:0000000000000138 $d
     /tmp/ccBaawNW.s:2441   .bss.testLineWidth:0000000000000000 testLineWidth
     /tmp/ccBaawNW.s:2442   .bss.testLineWidth:0000000000000000 $d
     /tmp/ccBaawNW.s:2444   .text.getLineWidth:0000000000000000 $t
     /tmp/ccBaawNW.s:2451   .text.getLineWidth:0000000000000000 getLineWidth
     /tmp/ccBaawNW.s:2668   .text.getLineWidth:000000000000010c $d
     /tmp/ccBaawNW.s:2675   .text.getLineLocCompare2MidLine:0000000000000000 $t
     /tmp/ccBaawNW.s:3191   .text.getLineLocCompare2MidLine:0000000000000364 $d
     /tmp/ccBaawNW.s:3204   .text.regression:0000000000000000 $t
     /tmp/ccBaawNW.s:3591   .text.regression:0000000000000314 $d
     /tmp/ccBaawNW.s:3601   .bss.line2stop.1:0000000000000000 $d
     /tmp/ccBaawNW.s:3606   .bss.slope2stop.0:0000000000000000 $d

UNDEFINED SYMBOLS
printStopMess
motation
print2lcd
memset
RUNNING
puts
printf
LCD_Scan_Dir
LCD_Set_Window
LCD_WriteRAM_Prepare
ov_sta
ov_frame
EXTI_ClearITPendingBit
__aeabi_dmul
__aeabi_d2iz
__aeabi_i2d
__aeabi_dadd
__aeabi_ddiv
__aeabi_dsub
__aeabi_dcmpeq
__aeabi_dcmpge
__aeabi_dcmple
